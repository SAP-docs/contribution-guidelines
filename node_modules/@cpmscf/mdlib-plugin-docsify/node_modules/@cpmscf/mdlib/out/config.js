"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadMkdocsConfig = exports.MKDOCS_DEFAULTS = exports.loadConfig = exports.defaultRcConfig = void 0;
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const YAML = require("yaml");
const glob_1 = require("./glob");
const log = require("debug")("config");
const { readFile } = require("fs").promises;
const path_1 = require("path");
function defaultRcConfig() {
    return {
        path: process.cwd(),
        config: "mkdocs.yml",
        ignore: [],
        profiles: {
            configurations: [],
        },
        mkdocs: {
            validateFiles: false,
            headingCase: true,
        },
        terms: [],
    };
}
exports.defaultRcConfig = defaultRcConfig;
function loadConfig(projectRoot = process.cwd()) {
    const previousCwd = process.cwd();
    process.chdir(projectRoot);
    const rcPath = require("rc")("cdc").config;
    let conf = defaultRcConfig();
    if (rcPath !== undefined) {
        // RC doesn't return paths when the files don't exist.
        const rcConf = JSON.parse(fs_1.readFileSync(rcPath, "utf-8"));
        if (rcConf.path)
            rcConf.path = path_1.join(conf.path, rcConf.path);
        conf = Object.assign(Object.assign({}, conf), rcConf);
    }
    process.chdir(previousCwd);
    return conf;
}
exports.loadConfig = loadConfig;
function discoverMkdocsConfig(rcConfig) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const pattern = path_1.join(process.cwd(), "**/mkdocs.yml");
        const globFiles = yield glob_1.globAsync(pattern, {
            ignore: (_a = rcConfig.dita) === null || _a === void 0 ? void 0 : _a.excludePatterns,
        });
        if (globFiles.length > 1) {
            throw new Error(`Multiple mkdocs.yml files found: ${globFiles.join(", ")}. Use the --config flag to point to the correct one.`);
        }
        if (globFiles.length === 0) {
            throw new Error(`No mkdocs.yml file(s) found in ${pattern}`);
        }
        return globFiles[0];
    });
}
exports.MKDOCS_DEFAULTS = {
    // eslint-disable-next-line camelcase
    docs_dir: "docs",
    plugins: [],
    // eslint-disable-next-line camelcase
    markdown_extensions: [],
    nav: [],
};
/**
 * Load mkdocs config from the specified options or raw config string.
 *
 * @param {string | Partial<RcConfig> | undefined} optsOrRawYaml Raw YAML string or options indicating config file location
 * @returns {MkdocsConfig} MkdocsConfig with defaults
 */
function loadMkdocsConfig(optsOrRawYaml) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let rawMkdocsConfig;
        if (typeof optsOrRawYaml === "string")
            rawMkdocsConfig = optsOrRawYaml;
        else {
            const defaults = defaultRcConfig();
            const options = Object.assign(Object.assign({}, defaults), optsOrRawYaml);
            const configPath = path_1.join(options.path || process.cwd(), options.config);
            try {
                rawMkdocsConfig = yield readFile(configPath, "utf-8");
            }
            catch (error) {
                if (error.code === "ENOENT" && options.config === defaults.config) {
                    log(`${configPath} not found, falling back to discovery...`);
                    rawMkdocsConfig = yield readFile(yield discoverMkdocsConfig(options), "utf-8");
                }
                else
                    throw error;
            }
        }
        // Register additional framework-related YAML tags to suppress warnings.
        const twemojiType = {
            identify: () => false,
            tag: "tag:yaml.org,2002:python/name:materialx.emoji.twemoji",
            resolve: () => undefined,
            stringify: () => "",
        };
        const toSvgType = Object.assign(Object.assign({}, twemojiType), { tag: "tag:yaml.org,2002:python/name:materialx.emoji.to_svg" });
        const yamlOpts = {
            customTags: [
                twemojiType,
                toSvgType,
            ],
        };
        const document = YAML.parseDocument(rawMkdocsConfig, yamlOpts);
        const config = YAML.parse(rawMkdocsConfig, yamlOpts);
        return Object.assign(Object.assign(Object.assign({}, exports.MKDOCS_DEFAULTS), config), { document, raw: rawMkdocsConfig });
    });
}
exports.loadMkdocsConfig = loadMkdocsConfig;
//# sourceMappingURL=config.js.map