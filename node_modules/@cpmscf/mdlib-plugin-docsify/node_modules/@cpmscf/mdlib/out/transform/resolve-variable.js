"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveVariables = exports.CODE_VARIABLE_ILLEGAL_CHAR = exports.CODE_VARIABLE_NESTED = exports.CODE_VARIABLE_NO_UNDEF = void 0;
const tslib_1 = require("tslib");
const visit = require("unist-util-visit");
const resolver_1 = require("../resolver");
const __1 = require("..");
const variable_1 = require("../compiler-plugin/variable");
const rxjs_1 = require("rxjs");
const kramdown_link_1 = require("../compiler-plugin/kramdown-link");
exports.CODE_VARIABLE_NO_UNDEF = "remark-lint:variable-no-undef";
const noUndefShortLink = "065y";
exports.CODE_VARIABLE_NESTED = "remark-lint:variable-nested";
const nestedShortLink = "065z";
exports.CODE_VARIABLE_ILLEGAL_CHAR = "remark-lint:variable-illegal-char";
const illegalCharShortLink = "0660";
// https://jinja.palletsprojects.com/en/master/api/#identifier-naming
const VARIABLE_NAME_REGEX = /^[a-zA-Z_]\w*(\.[a-zA-Z_]\w*)*$/;
const PLUGIN_MARKDOWNEXTRADATA = "markdownextradata";
function visitVariable(ast, file, resolver) {
    const variables = [];
    visit(ast, variable_1.NODE_TYPE_VARIABLE, (variable) => {
        variables.push(variable);
        return variable;
    });
    return Promise.all(variables.map((variable) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const value = String(variable.value);
        if (!VARIABLE_NAME_REGEX.test(value)) {
            const reason = `Variable '${value}' contains illegal characters. Allowed: '${VARIABLE_NAME_REGEX}'`;
            __1.makeMessage(exports.CODE_VARIABLE_ILLEGAL_CHAR, value, undefined, variable, reason, file, illegalCharShortLink);
            return;
        }
        const resolvedVariable = yield resolver.resolveVariable(value);
        if (resolvedVariable === undefined) {
            const reason = `Variable '${value}' is not defined.`;
            __1.makeMessage(exports.CODE_VARIABLE_NO_UNDEF, value, undefined, variable, reason, file, noUndefShortLink);
            return;
        }
        if (typeof resolvedVariable === "object") {
            const reason = `Variable ${value} has sub-terms: ${Object.keys(resolvedVariable).join(", ")}`;
            __1.makeMessage(exports.CODE_VARIABLE_NESTED, value, undefined, variable, reason, file, nestedShortLink);
            return;
        }
        // Quite frankly, if someone can explain why ESLint complains in this specific case, I'll gladly fix it. D053411 2020-07-23
        // eslint-disable-next-line require-atomic-updates
        variable.resolvedValue = resolvedVariable;
    })));
}
function resolveVariables(config) {
    var _a;
    const resolver = new resolver_1.VariableResolver(rxjs_1.of(config.mkdocsConfig));
    const plugin = (_a = config.mkdocsConfig.plugins) === null || _a === void 0 ? void 0 : _a.find(plugin => plugin[PLUGIN_MARKDOWNEXTRADATA] !== undefined);
    const jinjaOptions = plugin ? plugin[PLUGIN_MARKDOWNEXTRADATA].jinja_options : undefined;
    if (jinjaOptions) {
        if (jinjaOptions.variable_start_string)
            config.open = config.open || jinjaOptions.variable_start_string;
        if (jinjaOptions.variable_end_string)
            config.close = config.close || jinjaOptions.variable_end_string;
    }
    return function () {
        const scope = this.Parser.prototype.inlineTokenizers;
        const methods = this.Parser.prototype.inlineMethods;
        scope[variable_1.NODE_TYPE_VARIABLE] = variable_1.variableTokenizer(config);
        scope.link = kramdown_link_1.linkTokenizer;
        if (this.Compiler) {
            this.Compiler.prototype.visitors[variable_1.NODE_TYPE_VARIABLE] = (node) => {
                return `{{ ${node.value} }}`;
            };
        }
        // Specify order (just before `text`).
        methods.splice(methods.indexOf("text"), 0, variable_1.NODE_TYPE_VARIABLE);
        return function (ast, vFile, next) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield visitVariable(ast, vFile, resolver);
                }
                catch (error) {
                    console.error(error);
                }
                if (typeof next === "function") {
                    next(null, ast, vFile);
                }
                return ast;
            });
        };
    };
}
exports.resolveVariables = resolveVariables;
//# sourceMappingURL=resolve-variable.js.map