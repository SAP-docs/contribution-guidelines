"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.admonitionTokenizer = void 0;
const lineFeed = 10; //  '\n'
const space = 32; // ' '
const tab = 9;
const exclamationMark = 33; // !
const tabSize = 4;
function eatWhiteSpace(index, value) {
    while (index < value.length) {
        const character = value.charCodeAt(index);
        if (character !== space && character !== tab) {
            break;
        }
        index++;
    }
    return index;
}
// eslint-disable-next-line complexity
function admonitionTokenizerFn(eat, value) {
    const length = value.length;
    const marker = exclamationMark;
    const offsets = this.offset;
    let index = 0;
    let markerCount;
    let character;
    let tag;
    let queue;
    let content = "";
    const now = eat.now();
    // Eat initial spacing.
    index = eatWhiteSpace(index, value);
    const leadingIndent = index;
    // Eat the fence.
    character = value.charCodeAt(index);
    if (character !== marker) {
        return;
    }
    index++;
    markerCount = 1;
    while (index < length) {
        character = value.charCodeAt(index);
        if (character !== marker) {
            break;
        }
        markerCount++;
        index++;
    }
    // Eat spacing before tag.
    index = eatWhiteSpace(index, value);
    // Eat tag.
    tag = "";
    queue = "";
    while (index < length) {
        character = value.charCodeAt(index);
        if (character === lineFeed) {
            index++;
            break;
        }
        if (character === space || character === tab) {
            queue += String.fromCharCode(character);
        }
        else {
            tag += queue + String.fromCharCode(character);
            queue = "";
        }
        index++;
    }
    const exit = this.enterBlock();
    let newLine = false;
    let indent = 0;
    queue = "";
    while (index < length) {
        character = value.charCodeAt(index);
        queue += String.fromCharCode(character);
        if (character === lineFeed)
            newLine = true;
        else if (newLine && character === space)
            indent++;
        else {
            if (newLine && indent !== tabSize)
                break;
            content += queue;
            queue = "";
            newLine = false;
            indent = 0;
        }
        index++;
    }
    const contentLines = content.split(/\n/);
    // Set offset for nested content
    for (let i = 1; i <= contentLines.length; i++) {
        const currentLine = now.line + i;
        offsets[currentLine] = (offsets[currentLine] || 0) + tabSize;
    }
    const children = this.tokenizeBlock(content, now);
    index -= queue.length;
    exit();
    return eat(value.slice(0, index))({
        type: "admonition",
        tag,
        markerCount,
        children,
        indent: leadingIndent,
        value: content,
    });
}
exports.admonitionTokenizer = admonitionTokenizerFn;
//# sourceMappingURL=admonition.js.map