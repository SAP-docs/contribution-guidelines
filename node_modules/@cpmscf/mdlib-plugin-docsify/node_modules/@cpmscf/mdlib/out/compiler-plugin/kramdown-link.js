/**
 * Tweaked version of the original remark-parse link tokenizer,
 * extended to digest kramdown properties in curly braces after links/images.
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.linkTokenizer = void 0;
linkTokenizerFn.locator = locate;
const lineFeed = "\n";
const exclamationMark = "!";
const quotationMark = "\"";
const apostrophe = "'";
const leftParenthesis = "(";
const rightParenthesis = ")";
const lessThan = "<";
const greaterThan = ">";
const leftSquareBracket = "[";
const backslash = "\\";
const rightSquareBracket = "]";
const graveAccent = "`";
const openBrace = "{";
const colon = ":";
const closeBrace = "}";
function locate(value, fromIndex) {
    const link = value.indexOf("[", fromIndex);
    const image = value.indexOf("![", fromIndex);
    if (image === -1) {
        return link;
    }
    // Link can never be `-1` if an image is found, so we don’t need to check
    // for that :)
    return link < image ? link : image;
}
function whitespace(character) {
    return character === " " ||
        character === "\n" ||
        character === "\t" ||
        character === "\r";
}
function eatWhitespace(value, index) {
    let queue = "";
    let character;
    while (index < value.length) {
        character = value.charAt(index);
        if (!whitespace(character)) {
            break;
        }
        queue += character;
        index++;
    }
    return queue;
}
// eslint-disable-next-line complexity
function linkTokenizerFn(eat, value, silent) {
    let subvalue = "";
    let index = 0;
    let character = value.charAt(0);
    const pedantic = this.options.pedantic;
    const commonmark = this.options.commonmark;
    const gfm = this.options.gfm;
    let closed;
    let count;
    let opening;
    let beforeURL;
    let beforeTitle = "";
    let subqueue;
    let hasMarker;
    let isImage;
    let marker;
    const length = value.length;
    let title;
    let depth;
    let queue;
    let url;
    const now = eat.now();
    let exit;
    // Detect whether this is an image.
    if (character === exclamationMark) {
        isImage = true;
        subvalue = character;
        character = value.charAt(++index);
    }
    // Eat the opening.
    if (character !== leftSquareBracket) {
        return;
    }
    // Exit when this is a link and we’re already inside a link.
    if (!isImage && this.inLink) {
        return;
    }
    subvalue += character;
    queue = "";
    index++;
    // Eat the content.
    depth = 0;
    now.column += index;
    now.offset += index;
    while (index < length) {
        character = value.charAt(index);
        subqueue = character;
        if (character === graveAccent) {
            // Inline-code in link content.
            count = 1;
            while (value.charAt(index + 1) === graveAccent) {
                subqueue += character;
                index++;
                count++;
            }
            if (!opening) {
                opening = count;
            }
            else if (count >= opening) {
                opening = 0;
            }
        }
        else if (character === backslash) {
            // Allow brackets to be escaped.
            index++;
            subqueue += value.charAt(index);
        }
        else if ((!opening || gfm) && character === leftSquareBracket) {
            // In GFM mode, brackets in code still count.  In all other modes,
            // they don’t.
            depth++;
        }
        else if ((!opening || gfm) && character === rightSquareBracket) {
            if (depth) {
                depth--;
            }
            else {
                if (value.charAt(index + 1) !== leftParenthesis) {
                    return;
                }
                subqueue += leftParenthesis;
                closed = true;
                index++;
                break;
            }
        }
        queue += subqueue;
        subqueue = "";
        index++;
    }
    // Eat the content closing.
    if (!closed) {
        return;
    }
    const content = queue;
    subvalue += queue + subqueue;
    index++;
    queue = eatWhitespace(value, index);
    subvalue += queue;
    index += queue.length;
    // Eat the URL.
    character = value.charAt(index);
    queue = "";
    beforeURL = subvalue;
    if (character === lessThan) {
        index++;
        beforeURL += lessThan;
        while (index < length) {
            character = value.charAt(index);
            if (character === greaterThan) {
                break;
            }
            if (commonmark && character === lineFeed) {
                return;
            }
            queue += character;
            index++;
        }
        if (value.charAt(index) !== greaterThan) {
            return;
        }
        subvalue += lessThan + queue + greaterThan;
        url = queue;
        index++;
    }
    else {
        character = null;
        subqueue = "";
        while (index < length) {
            character = value.charAt(index);
            if (subqueue &&
                (character === quotationMark ||
                    character === apostrophe ||
                    (commonmark && character === leftParenthesis))) {
                break;
            }
            if (whitespace(character)) {
                if (!pedantic) {
                    break;
                }
                subqueue += character;
            }
            else {
                if (character === leftParenthesis) {
                    depth++;
                }
                else if (character === rightParenthesis) {
                    if (depth === 0) {
                        break;
                    }
                    depth--;
                }
                queue += subqueue;
                subqueue = "";
                if (character === backslash) {
                    queue += backslash;
                    character = value.charAt(++index);
                }
                queue += character;
            }
            index++;
        }
        subvalue += queue;
        url = queue;
        index = subvalue.length;
    }
    // Eat white-space.
    queue = eatWhitespace(value, index);
    index += queue.length;
    character = value.charAt(index);
    subvalue += queue;
    // Eat the title.
    if (queue &&
        (character === quotationMark ||
            character === apostrophe ||
            (commonmark && character === leftParenthesis))) {
        index++;
        subvalue += character;
        queue = "";
        marker = character === leftParenthesis ? rightParenthesis : character;
        beforeTitle = subvalue;
        // In commonmark-mode, things are pretty easy: the marker cannot occur
        // inside the title.  Non-commonmark does, however, support nested
        // delimiters.
        if (commonmark) {
            while (index < length) {
                character = value.charAt(index);
                if (character === marker) {
                    break;
                }
                if (character === backslash) {
                    queue += backslash;
                    character = value.charAt(++index);
                }
                index++;
                queue += character;
            }
            character = value.charAt(index);
            if (character !== marker) {
                return;
            }
            title = queue;
            subvalue += queue + character;
            index++;
            while (index < length) {
                character = value.charAt(index);
                if (!whitespace(character)) {
                    break;
                }
                subvalue += character;
                index++;
            }
        }
        else {
            subqueue = "";
            while (index < length) {
                character = value.charAt(index);
                if (character === marker) {
                    if (hasMarker) {
                        queue += marker + subqueue;
                        subqueue = "";
                    }
                    hasMarker = true;
                }
                else if (!hasMarker) {
                    queue += character;
                }
                else if (character === rightParenthesis) {
                    subvalue += queue + marker + subqueue;
                    title = queue;
                    break;
                }
                else if (whitespace(character)) {
                    subqueue += character;
                }
                else {
                    queue += marker + subqueue + character;
                    subqueue = "";
                    hasMarker = false;
                }
                index++;
            }
        }
    }
    if (value.charAt(index) !== rightParenthesis) {
        return;
    }
    /* istanbul ignore if - never used (yet) */
    if (silent) {
        return true;
    }
    subvalue += rightParenthesis;
    index++;
    url = this.decode.raw(this.unescape(url), eat(beforeURL).test().end, {
        nonTerminated: false,
    });
    if (title) {
        beforeTitle = eat(beforeTitle).test().end;
        title = this.decode.raw(this.unescape(title), beforeTitle);
    }
    queue = eatWhitespace(value, index);
    index += queue.length;
    character = value.charAt(index);
    let props;
    if (character === openBrace) {
        queue += character;
        index++;
        character = value.charAt(index);
        if (character === colon) {
            const propsStartIndex = index + 1;
            while (character !== closeBrace && index < length) {
                queue += character;
                index++;
                character = value.charAt(index);
            }
            if (character === closeBrace) {
                queue += character;
                props = value.substring(propsStartIndex, index);
                subvalue += queue;
            }
        }
    }
    const node = {
        type: isImage ? "image" : "link",
        title: title || null,
        url: url,
        children: [],
        kramdownProperties: props,
    };
    if (isImage) {
        node.alt = this.decode.raw(this.unescape(content), now) || null;
    }
    else {
        exit = this.enterLink();
        node.children = this.tokenizeInline(content, now);
        exit();
    }
    return eat(subvalue)(node);
}
exports.linkTokenizer = linkTokenizerFn;
//# sourceMappingURL=kramdown-link.js.map