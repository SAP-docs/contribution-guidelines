"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.factory = void 0;
const lineFeed = 10; //  '\n'
const space = 32; // ' '
const internalDefaults = {
    isIllegalChar: () => false,
};
function factory(defaultOptions) {
    return function (opts) {
        const options = Object.assign(Object.assign(Object.assign({}, internalDefaults), defaultOptions), opts);
        // eslint-disable-next-line complexity
        function tokenizer(eat, value, silent) {
            let length = value.length;
            let index = 0;
            let openingFenceEnd;
            let closingFenceStart;
            let closingFenceEnd;
            let code;
            let next;
            let found;
            while (index < length) {
                if (value.charCodeAt(index) !== options.open.charCodeAt(index)) {
                    break;
                }
                index++;
            }
            if (index === 0 || index === length) {
                return;
            }
            openingFenceEnd = index;
            next = value.charCodeAt(index);
            let closeIndex = 0;
            while (index < length) {
                code = next;
                next = value.charCodeAt(index + 1);
                if (code === options.close.charCodeAt(closeIndex)) {
                    closeIndex++;
                    if (closingFenceStart === undefined) {
                        closingFenceStart = index;
                    }
                    closingFenceEnd = index + 1;
                    if (next !== options.close.charCodeAt(closeIndex) &&
                        closingFenceEnd - closingFenceStart === options.close.length) {
                        found = true;
                        break;
                    }
                }
                else if (options.isIllegalChar(code)) {
                    break;
                }
                else if (closingFenceStart !== undefined) {
                    closingFenceStart = undefined;
                    closingFenceEnd = undefined;
                }
                index++;
            }
            if (!found) {
                return;
            }
            if (silent) {
                return true;
            }
            // Remove the initial and final space (or line feed), iff they exist and there
            // are non-space characters in the content.
            index = openingFenceEnd;
            closingFenceStart = closingFenceStart;
            length = closingFenceStart;
            code = value.charCodeAt(index);
            next = value.charCodeAt(length - 1);
            found = false;
            if (length - index > 2 &&
                (code === space || code === lineFeed) &&
                (next === space || next === lineFeed)) {
                index++;
                length--;
                while (index < length) {
                    code = value.charCodeAt(index);
                    if (code !== space && code !== lineFeed) {
                        found = true;
                        break;
                    }
                    index++;
                }
                if (found === true) {
                    openingFenceEnd++;
                    closingFenceStart--;
                }
            }
            return eat(value.slice(0, closingFenceEnd))({
                type: options.nodeType,
                value: value.slice(openingFenceEnd, closingFenceStart),
            });
        }
        tokenizer.locator = function (value, fromIndex) {
            return value.indexOf(options.open, fromIndex);
        };
        return tokenizer;
    };
}
exports.factory = factory;
//# sourceMappingURL=fenced-tokenizer.js.map