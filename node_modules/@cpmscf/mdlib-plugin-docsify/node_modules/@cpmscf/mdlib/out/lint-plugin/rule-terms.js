/**
 * @author D053411
 * @copyright 2020 SAP SE
 * @license SEE LICENSE IN LICENSE
 * @module titlecase
 * @fileoverview
 *   Warn when headings increment with more than 1 level at a time.
 *
 * @example {"name": "ok.md"}
 *
 *   # Alpha
 *
 *   ## Bravo
 *
 * @example {"name": "not-ok.md", "label": "input"}
 *
 *   # Charlie
 *
 *   ### Delta
 *
 * @example {"name": "not-ok.md", "label": "output"}
 *
 *   3:1-3:10: Heading levels should increment by one level at a time
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.termRule = void 0;
const rule = require("unified-lint-rule");
const visit = require("unist-util-visit-parents");
const generated = require("unist-util-generated");
const helpers_1 = require("../helpers");
const REASON_INAPPROPRIATE_TERM = "Use of inappropriate term";
const SHORT_LINK_INAPPROPRIATE_TERM = "06rn";
function makeReason(term, replacement) {
    const replacements = replacement.replace;
    const replace = replacements.length > 1 ?
        `either of '${replacements.join("', '")}'` :
        `'${replacements[0]}'`;
    return replacement.comment ? replacement.comment :
        `${REASON_INAPPROPRIATE_TERM} '${term}'. Replace it with ${replace}.`;
}
const CODE_INAPPROPRITE_TERMS = "remark-lint:terms";
function positionFromMatch(text, match) {
    if (text.position === undefined)
        throw new Error("Node is missing required position");
    const position = text.position;
    if (position.indent === undefined)
        throw new Error("Node is missing required indent");
    const indent = position.indent;
    if (match.index === undefined)
        throw new Error("Match is missing required index");
    const content = String(text.value);
    const lines = content.split(/\n/);
    let correctedMatchIndex = match.index;
    let currentIndex = 0;
    let startLineOffset = 0;
    let endLineOffset = 0;
    let endOffset = match[0].length;
    lines.forEach((l, i) => {
        currentIndex += l.length + 1;
        if (match.index > currentIndex) {
            correctedMatchIndex += indent[i] - 1; // one off, probably related to \n handling
            startLineOffset++;
        }
        else if (match.index + match[0].length > currentIndex) { // if the match wraps to further lines
            endOffset += indent[i] - 1;
            endLineOffset++;
        }
    });
    const start = position.start.offset + correctedMatchIndex;
    const beforeMatchLines = content.substr(0, match.index).split(/\n/);
    const startColumn = beforeMatchLines[beforeMatchLines.length - 1].length +
        (startLineOffset > 0 ? indent[startLineOffset - 1] : 1);
    const matchLines = match[0].split(/\n/);
    const endColumn = matchLines[matchLines.length - 1].length +
        (startLineOffset + endLineOffset > 0 ? indent[startLineOffset + endLineOffset - 1] : match.index + 1);
    return {
        start: {
            line: text.position.start.line + startLineOffset,
            column: startColumn,
            offset: start,
        },
        end: {
            line: text.position.start.line + startLineOffset + endLineOffset,
            column: endColumn,
            offset: start + endOffset,
        },
    };
}
function termRule(config) {
    return rule(CODE_INAPPROPRITE_TERMS, function (tree, file) {
        visit(tree, "text", visitText);
        function visitText(textNode, ancestors) {
            if (generated(textNode))
                return;
            const replacements = config.terms.map(r => {
                return Object.assign(Object.assign({ includeNodes: [], excludeNodes: [] }, r), { match: new RegExp(`\\b${r.match.split(/\s/).join("\\s+")}\\b`, "g") });
            });
            const text = String(textNode.value);
            for (const replacement of replacements) {
                if (doesNotMatchNodeLimitation(replacement, ancestors))
                    return;
                let match;
                // eslint-disable-next-line no-cond-assign
                while (match = replacement.match.exec(text)) {
                    const position = positionFromMatch(textNode, match);
                    let fixedContent;
                    if (replacement.replace[0].indexOf("$") === -1) {
                        fixedContent = replacement.replace[0];
                    }
                    else {
                        // Clone Regex without global flag to propose replacement with Regex features
                        const substr = text.substr(match.index, match[0].length);
                        const replaceRegexp = new RegExp(replacement.match.source);
                        fixedContent = substr.replace(replaceRegexp, replacement.replace[0]);
                    }
                    helpers_1.makeMessage(CODE_INAPPROPRITE_TERMS, match[0], fixedContent, position, makeReason(match[0], replacement), file, SHORT_LINK_INAPPROPRIATE_TERM);
                }
            }
        }
    });
}
exports.termRule = termRule;
/**
 * Tells if the list of ancestors does not match the replacement node limitation, i.e.
 * 1. The list of ancestors *contains* any node types specified in `replacement.excludeNodes` or
 * 1. The list of ancestors *does not contain* any node types specified in `replacement.includeNodes`.
 *
 * @param {ParsedTermReplacement} replacement Replacement config to use
 * @param {unist.Node[]} ancestors List of ancestors to qualify
 * @returns {boolean} false if the replacement config indicates that this node hierarchy should be processed;
 *  false otherwise
 */
function doesNotMatchNodeLimitation(replacement, ancestors) {
    const hasAncestorWithType = (t) => {
        return ancestors.find(a => a.type === t) !== undefined;
    };
    if (replacement.excludeNodes.length > 0) {
        return replacement.excludeNodes.find(hasAncestorWithType) !== undefined;
    }
    if (replacement.includeNodes.length > 0) {
        return replacement.includeNodes.find(hasAncestorWithType) === undefined;
    }
    return false;
}
//# sourceMappingURL=rule-terms.js.map