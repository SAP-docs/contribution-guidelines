"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.profileRule = exports.CODE_PROFILE_BAD_EXPR = exports.CODE_PROFILE_ILLEGAL_CHAR = exports.CODE_PROFILE_UNMATCHED_ENDIF = exports.CODE_PROFILE_UNMATCHED_IF = exports.CODE_PROFILE_UNDEF = exports.CODE_LINK_TO_PROFILED_CONTENT = void 0;
const tslib_1 = require("tslib");
const __1 = require("..");
const html_block_1 = require("../compiler-plugin/html-block");
const boolean_expressions_1 = require("boolean-expressions");
const profile_1 = require("../compiler-plugin/profile");
exports.CODE_LINK_TO_PROFILED_CONTENT = "remark-lint:link-profiled";
const unprofiledLinkShortLink = "0671";
exports.CODE_PROFILE_UNDEF = "remark-lint:profile-undefined";
const undefShortLink = "0670";
exports.CODE_PROFILE_UNMATCHED_IF = "remark-lint:profile-if-unmatched";
const unmatchedIfShortLink = "06ib";
exports.CODE_PROFILE_UNMATCHED_ENDIF = "remark-lint:profile-endif-unmatched";
const unmatchedEndIfShortLink = "06ic";
exports.CODE_PROFILE_ILLEGAL_CHAR = "remark-lint:profile-illegal-char";
const illegalCharShortLink = "06id";
exports.CODE_PROFILE_BAD_EXPR = "remark-lint:profile-bad-expr";
const badExprShortLink = "06ie";
const LEGAL_CHAR_REGEX = /^[\w ()]+$/;
function isParent(node) {
    return node.children !== undefined;
}
function visitProfile(ast, vFile, options, exprStack = []) {
    const node = ast;
    if (node.type === "html" && profile_1.PROFILE_BLOCK_END.test(String(node.value))) {
        const reason = "This endif-block isn't matched by an if-block.";
        __1.makeMessage(exports.CODE_PROFILE_UNMATCHED_ENDIF, String(node.value), undefined, node, reason, vFile, unmatchedEndIfShortLink);
    }
    if (node.type === profile_1.NODE_TYPE_PROFILE) {
        const rawExpr = String(node.value);
        if (!LEGAL_CHAR_REGEX.test(rawExpr)) {
            const reason = `This condition contains illegal chars. Allowed: '${LEGAL_CHAR_REGEX}'`;
            __1.makeMessage(exports.CODE_PROFILE_ILLEGAL_CHAR, rawExpr, undefined, node, reason, vFile, illegalCharShortLink);
            return;
        }
        if (!node.endFound) {
            const reason = "This if-block isn't matched by an endif-block.";
            __1.makeMessage(exports.CODE_PROFILE_UNMATCHED_IF, rawExpr, undefined, node, reason, vFile, unmatchedIfShortLink);
            return;
        }
        try {
            const expr = new boolean_expressions_1.default(rawExpr);
            for (const tag of expr.getVariableNames()) {
                for (const config of options.configurations) {
                    // eslint-disable-next-line max-depth
                    if (config.includes.indexOf(tag) === -1 && config.excludes.indexOf(tag) === -1) {
                        const reason = `The tag '${tag}' is missing in profile '${config.name}'`;
                        __1.makeMessage(exports.CODE_PROFILE_UNDEF, rawExpr, undefined, node, reason, vFile, undefShortLink);
                    }
                }
            }
            exprStack.push(expr);
        }
        catch (error) {
            const reason = `The expression '${rawExpr}' could not be parsed: ${error.message}`;
            __1.makeMessage(exports.CODE_PROFILE_BAD_EXPR, rawExpr, undefined, node, reason, vFile, badExprShortLink);
        }
    }
    else if (node.type === "link") {
        // Every path part of a link URL may be used as a profile
        const url = String(node.url);
        if (!/^https?/.test(url)) {
            const linkPathParts = String(url).split(/\//);
            const filePathParts = vFile.path.split(/\//);
            // For each path part, each of which may be used as profiling tag...
            for (const part of linkPathParts) {
                // And for each profile
                for (const profile of options.configurations) {
                    const fileNotExcluded = filePathParts.find(part => profile.excludes.indexOf(part) !== -1) === undefined;
                    // eslint-disable-next-line max-depth
                    if (profile.excludes.indexOf(part) !== -1 &&
                        fileNotExcluded) {
                        const isRendered = exprStack.reduce((p, c) => p && c.evaluate(profile.includes), true);
                        // eslint-disable-next-line max-depth
                        if (isRendered) {
                            const reason = `Link points to folder '${part}', which is excluded in profile '${profile.name}'.`;
                            __1.makeMessage(exports.CODE_LINK_TO_PROFILED_CONTENT, url, undefined, node, reason, vFile, unprofiledLinkShortLink);
                        }
                    }
                }
            }
        }
    }
    if (isParent(node)) {
        node.children.forEach(child => visitProfile(child, vFile, options, exprStack));
    }
}
const DEFAULT_CONFIG = {
    configurations: [],
};
function profileRule(options = DEFAULT_CONFIG) {
    return function () {
        const scope = this.Parser.prototype.blockTokenizers;
        const methods = this.Parser.prototype.blockMethods;
        const interruptList = this.Parser.prototype.interruptList;
        this.Parser.prototype.interruptHtml = this.Parser.prototype.interruptHtml || [];
        const interruptHtml = this.Parser.prototype.interruptHtml;
        scope[profile_1.NODE_TYPE_PROFILE] = profile_1.profileTokenizer;
        if (this.Compiler) {
            // Not a use case atm
            this.Compiler.prototype.visitors[profile_1.NODE_TYPE_PROFILE] = () => undefined;
        }
        // Specify order (just before `html`).
        methods.splice(methods.indexOf("html"), 0, profile_1.NODE_TYPE_PROFILE);
        methods[methods.indexOf("html")] = html_block_1.htmlTokenizer;
        interruptList.push([
            profile_1.NODE_TYPE_PROFILE,
            { pedantic: false },
        ]);
        interruptHtml.push([
            profile_1.NODE_TYPE_PROFILE,
            { pedantic: false },
        ]);
        return function (ast, vFile, next) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield visitProfile(ast, vFile, options);
                }
                catch (error) {
                    console.error(error);
                }
                if (typeof next === "function") {
                    next(null, ast, vFile);
                }
                return ast;
            });
        };
    };
}
exports.profileRule = profileRule;
//# sourceMappingURL=rule-profile.js.map