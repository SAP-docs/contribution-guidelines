/* eslint-disable no-await-in-loop */
/**
 * @author D053411
 * @copyright 2020 SAP SE
 * @license SEE LICENSE IN LICENSE
 * @module titlecase
 * @fileoverview
 *   Warn when headings increment with more than 1 level at a time.
 *
 * @example {"name": "ok.md"}
 *
 *   # Alpha
 *
 *   ## Bravo
 *
 * @example {"name": "not-ok.md", "label": "input"}
 *
 *   # Charlie
 *
 *   ### Delta
 *
 * @example {"name": "not-ok.md", "label": "output"}
 *
 *   3:1-3:10: Heading levels should increment by one level at a time
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.linkTargetExistsRule = void 0;
const tslib_1 = require("tslib");
const rule = require("unified-lint-rule");
const visit = require("unist-util-visit");
const generated = require("unist-util-generated");
const helpers_1 = require("../helpers");
const path_1 = require("path");
const util_1 = require("util");
const url_1 = require("url");
const reasonFileNotFound = "The target file '%s' could not be found.";
const fileNotFoundShortLink = "065q";
const reasonHashNotFound = "The target hash '%s' could not be found in file '%s'. Available hashes: '%s'";
const hashNotFoundShortLink = "065r";
const CODE_FILE = "issue.link.file";
const CODE_HASH = "issue.link.hash";
const PROTOCOL_REGEX = /^\w+:\/\//;
function linkTargetExistsRule(targetFinder) {
    return rule("remark-lint:link-target-exists", function (tree, file) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const links = [];
            function visitLink(link) {
                if (generated(link))
                    return;
                links.push(link);
            }
            visit(tree, "link", visitLink);
            visit(tree, "image", visitLink);
            for (const link of links) {
                const originFile = file.path.match(PROTOCOL_REGEX) ? url_1.fileURLToPath(file.path) : file.path;
                const href = String(link.url);
                if (href.match(PROTOCOL_REGEX))
                    continue; // External URL
                const originalUrl = href.split("#")[0] || originFile;
                const isIntraFile = originalUrl === originFile;
                const hrefRelativeToRoot = isIntraFile ?
                    originFile + href : // [#hash] ---> path/to/file.md#hash
                    path_1.join(path_1.dirname(originFile), href); // [test.md#hash] in path/to.md --> path/test.md#hash
                const split = hrefRelativeToRoot.split(("#"));
                const url = split[0] || originFile;
                const hash = split[1];
                if ((yield targetFinder.exists(url, hash)) === true)
                    continue;
                if ((yield targetFinder.exists(url)) === true) {
                    const availableHashes = [...(yield targetFinder.hashesIn(url))].join("', '");
                    helpers_1.makeMessage(CODE_HASH, originalUrl, undefined, link, util_1.format(reasonHashNotFound, `#${hash}`, url, `${availableHashes}`), file, hashNotFoundShortLink);
                }
                else {
                    helpers_1.makeMessage(CODE_FILE, originalUrl, undefined, link, util_1.format(reasonFileNotFound, hrefRelativeToRoot), file, fileNotFoundShortLink);
                }
            }
            return tree;
        });
    });
}
exports.linkTargetExistsRule = linkTargetExistsRule;
//# sourceMappingURL=rule-link-target-exists.js.map