"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MkdocsValidator = exports.CODE_FILE_NOT_LINKED = exports.CODE_FILE_NOT_FOUND = void 0;
const tslib_1 = require("tslib");
const path_1 = require("path");
const vfile = require("vfile");
const helpers_1 = require("../helpers");
const title_case_1 = require("title-case");
const rule_heading_case_1 = require("../lint-plugin/rule-heading-case");
exports.CODE_FILE_NOT_FOUND = "mkdocs-lint:file-not-found";
exports.CODE_FILE_NOT_LINKED = "mkdocs-lint:file-not-linked";
function isTopicHead(node) {
    return node.type === "MAP" &&
        node.items.length === 1 &&
        node.items[0].type === "PAIR" &&
        node.items[0].value.type === "SEQ";
}
function isTopicRefWithTitle(node) {
    return node.type === "MAP" &&
        node.items.length === 1 &&
        node.items[0].type === "PAIR" &&
        (node.items[0].value.type === "PLAIN" ||
            node.items[0].value.type === "QUOTE_SINGLE" ||
            node.items[0].value.type === "QUOTE_DOUBLE");
}
/**
 * Validator for mkdocs configuration:
 * 1. Validates files linked in `nav` exist (relative to `docs_dir` and `rcConfig.path`)
 * 2. Validates Markdown files in `rcConfig.path` are linked in `nav`
 */
class MkdocsValidator {
    constructor(rcConfig, finder, glob) {
        this.rcConfig = rcConfig;
        this.finder = finder;
        this.glob = glob;
    }
    /**
     * Validates the specified `conf` does not contain any issues.
     *
     * @param conf The configuration to check
     * @returns {VFile[]} Array of VFiles representing 1) mkdocs.yml (always), 2) all unlinked files (if any)
     */
    validate(conf) {
        var _a, _b, _c, _d, _e;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const nav = ((_e = (_d = (_c = (_b = (_a = conf.document) === null || _a === void 0 ? void 0 : _a.contents) === null || _b === void 0 ? void 0 : _b.items) === null || _c === void 0 ? void 0 : _c.find((i) => i.key.value === "nav")) === null || _d === void 0 ? void 0 : _d.value) === null || _e === void 0 ? void 0 : _e.items) || [];
            const filesAndHeadings = this.filesAndHeadingsIn(conf, nav);
            const mkdocsVFile = vfile({ path: this.rcConfig.config });
            mkdocsVFile.rawContents = conf.raw;
            const files = [yield this.validateLinks(mkdocsVFile, filesAndHeadings.files)];
            if (this.rcConfig.mkdocs.validateFiles) {
                files.push(...(yield this.validateFiles(filesAndHeadings.files)));
            }
            if (this.rcConfig.mkdocs.headingCase) {
                this.validateHeadings(mkdocsVFile, filesAndHeadings.headings);
            }
            return files;
        });
    }
    /**
     * Walks the `nav` tree and creates a map of file paths to locations where they occur.
     *
     * @param conf The configuration to check
     * @param nav The `nav` root
     * @param acc Accumulator for recursion
     * @returns Map of file to location(s)
     */
    filesAndHeadingsIn(conf, nav, acc = { files: {}, headings: [] }) {
        return nav.reduce((acc, item) => {
            let path;
            let heading;
            if (isTopicHead(item)) {
                heading = item.items[0].key;
                acc.headings.push({
                    heading: heading.value,
                    position: helpers_1.position(conf.raw, heading.range),
                });
                return this.filesAndHeadingsIn(conf, item.items[0].value.items, acc);
            }
            if (isTopicRefWithTitle(item)) {
                path = item.items[0].value.value;
                heading = item.items[0].key;
                acc.headings.push({
                    heading: heading.value,
                    position: helpers_1.position(conf.raw, heading.range),
                });
            }
            else {
                path = item.value;
            }
            if (path.startsWith("http"))
                return acc;
            path = path_1.join(conf.docs_dir, path);
            const bucket = acc.files[path] || [];
            bucket.push(helpers_1.position(conf.raw, item.range));
            acc.files[path] = bucket;
            return acc;
        }, acc);
    }
    /**
     * Validates all the links in `conf` point to existing files
     *
     * @param {VFile} vFile Virtual file representing mkdocs config
     * @param filesInConf Files to check
     * @returns {VFile} VFile representing the mkdocs config file. Check `VFile#messages` to see if it had issues.
     */
    validateLinks(vFile, filesInConf) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const exists = yield Promise.all(Object.keys(filesInConf).map(p => this.finder.exists(p)));
            Object.keys(filesInConf)
                .filter((_, i) => !exists[i])
                .forEach(path => {
                filesInConf[path].map(position => {
                    const msg = vFile.message(`File '${path}' does not exist`, position);
                    msg.ruleId = exports.CODE_FILE_NOT_FOUND;
                    return msg;
                });
            });
            return vFile;
        });
    }
    /**
     * Validates all the files in `rcConf.path` are linked in `conf.nav`
     *
     * @param filesInConf Files to check
     * @returns {VFile[]} Array with unlinked files
     */
    validateFiles(filesInConf) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (yield this.glob("**/*.{md,markdown}", {
                cwd: this.rcConfig.path,
                ignore: (_a = this.rcConfig.dita) === null || _a === void 0 ? void 0 : _a.excludePatterns,
            }))
                .filter(p => filesInConf[p] === undefined)
                .map(pathRelativeToRoot => {
                const pathRelativeToCwd = path_1.join(this.rcConfig.path, pathRelativeToRoot);
                const vFile = vfile({ path: pathRelativeToRoot });
                const msg = vFile.message(`File '${pathRelativeToCwd}' exists but is not referenced in mkdocs.yml`, {
                    line: 0, column: 0, offset: 0,
                });
                msg.ruleId = exports.CODE_FILE_NOT_LINKED;
                return vFile;
            });
        });
    }
    validateHeadings(vFile, headings) {
        headings.forEach(it => {
            const changed = title_case_1.titleCase(it.heading);
            if (it.heading !== changed) {
                helpers_1.makeMessage(rule_heading_case_1.CODE_HEADING_CASE, it.heading, changed, it.position, rule_heading_case_1.REASON_HEADING_CASE, vFile, rule_heading_case_1.SHORT_LINK_HEADING_CASE);
            }
        });
    }
}
exports.MkdocsValidator = MkdocsValidator;
//# sourceMappingURL=validator.js.map