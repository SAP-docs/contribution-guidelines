"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyFixes = exports.isReference = void 0;
const diff_merge_1 = require("@asmartbear/diff-merge");
/**
 * Tells if the specified nav entry is a topic reference.
 *
 * @param navEntry Nav entry to check
 * @returns true iff the nav entry is an instance of Reference
 */
function isReference(navEntry) {
    return Object.getOwnPropertyDescriptor(navEntry, "path") !== undefined;
}
exports.isReference = isReference;
function applyFixes(file) {
    if (!file.rawContents)
        throw new Error("Missing expected raw file contents in vfile");
    const originalContent = file.rawContents;
    let content = originalContent;
    const offsets = [];
    file.messages.forEach((message) => {
        if (message.fix === undefined || message.content === undefined)
            return;
        const offset = offsets.reduce((acc, o) => {
            return o.index <= message.location.start.offset ? acc + o.offset : acc;
        }, 0);
        const startIndex = message.location.start.offset + offset;
        const endIndex = message.location.end.offset + offset;
        const contentBeforeFix = content.substring(0, startIndex);
        const contentToFix = content.substring(startIndex, endIndex);
        const contentAfterFix = content.substring(endIndex, content.length);
        if (contentToFix !== message.content) {
            // Overlapping fixes may interfere - check if we can automatically merge fixes, else report an error
            const mergedContent = threeWayMerge(message.content, contentToFix, message.fix.content);
            if (mergedContent !== message.fix.content)
                throw new Error(`Could not apply fix '${message.fix.content}', likely due to conflicting rules in your configuration. Please resolve the issue manually.`);
        }
        offsets.push({
            index: startIndex + message.fix.content.length,
            offset: message.fix.content.length - contentToFix.length,
        });
        content = contentBeforeFix + message.fix.content + contentAfterFix;
    });
    return content;
}
exports.applyFixes = applyFixes;
function threeWayMerge(o, a, b) {
    const eng = new diff_merge_1.StringEngine();
    const patch1 = eng.getEditsByCharacter(o, a);
    const patch2 = eng.getEditsByCharacter(o, b);
    const merge = new diff_merge_1.Merge();
    // eslint-disable-next-line camelcase
    merge.opt_combine_overlapping_inserts = 0;
    merge.opt_algorithm_combined_overlapping_inserts;
    return merge.merge3(patch1, patch2).join("");
}
//# sourceMappingURL=lib.js.map