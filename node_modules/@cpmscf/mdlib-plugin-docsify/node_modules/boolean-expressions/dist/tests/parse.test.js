"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = __importDefault(require("../"));
describe("simple error handling tests", function () {
    it('evaluates "p AND q" not to throw an error', function () {
        expect(function () { return new __1.default("p AND q"); }).not.toThrowError();
    });
    it('evaluates "p and q OR r" not to throw an error', function () {
        expect(function () { return new __1.default("p and q OR r"); }).not.toThrowError();
    });
    it('evaluates "p q" to throw an error', function () {
        expect(function () { return new __1.default("p q"); }).toThrowError();
    });
    it('evaluates "p AND q OR" to throw an error', function () {
        expect(function () { return new __1.default("p AND q OR"); }).toThrowError();
    });
});
describe("parenthesis error handling tests", function () {
    it('evaluates "(p AND q) OR r" not to throw an error', function () {
        expect(function () { return new __1.default("(p AND q) OR r"); }).not.toThrowError();
    });
    it('evaluates "(p AND (q OR r))" not to throw an error', function () {
        expect(function () { return new __1.default("(p AND (q OR r))"); }).not.toThrowError();
    });
    it('evaluates "(p AND (q OR r)" to throw an error', function () {
        expect(function () { return new __1.default("(p AND (q OR r)"); }).toThrowError();
    });
});
describe("special keyword error handling tests", function () {
    it('evaluates "p OR OR q" to throw an error', function () {
        expect(function () { return new __1.default("p OR OR q"); }).toThrowError();
    });
    it('evaluates "not p" not to throw an error', function () {
        expect(function () { return new __1.default("not p"); }).not.toThrowError();
    });
    it('evaluates "not" to throw an error', function () {
        expect(function () { return new __1.default("not"); }).toThrowError();
    });
    it('evaluates "( not ) or ( not )" to throw an error', function () {
        expect(function () { return new __1.default("( not ) or ( not )"); }).toThrowError();
    });
});
describe("expressions with invalid tokens", function () {
    it('evaluates "(p AND {q}) OR r" to throw an error', function () {
        expect(function () { return new __1.default("(p AND {q}) OR r"); }).toThrowError();
    });
});
