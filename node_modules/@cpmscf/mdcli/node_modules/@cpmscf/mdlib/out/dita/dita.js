"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DitaConverter = exports.isTopicRef = exports.nodeToText = exports.ditaOptionsWithDefaults = void 0;
const tslib_1 = require("tslib");
const path_1 = require("path");
const { readFile, mkdir } = require("fs").promises;
const fs_1 = require("fs");
const remark = require("remark");
const frontmatter = require("remark-frontmatter");
const YAML = require("yaml");
const rule = require("unified-lint-rule");
const visit = require("unist-util-visit");
const generated = require("unist-util-generated");
const log = require("debug")("dita");
const title_case_1 = require("title-case");
const vfile = require("vfile");
const config_1 = require("../config");
const plugin_1 = require("./plugin");
const simple_git_1 = require("simple-git");
const minimatch = require("minimatch");
const archiver = require("archiver");
const builder = require("xmlbuilder");
const __1 = require("..");
const helpers_1 = require("../helpers");
const variable_1 = require("../compiler-plugin/variable");
const url_1 = require("url");
function ditaOptionsWithDefaults(partial) {
    if (partial.dita !== undefined &&
        partial.dita.editBase !== undefined &&
        !partial.dita.editBase.endsWith("/")) {
        // Ensure trailing slash, since semantically this has to be a directory.
        partial.dita.editBase += "/";
    }
    return Object.assign(Object.assign(Object.assign(Object.assign({}, config_1.defaultRcConfig()), { excludePatterns: [] }), partial), { dita: Object.assign({ outputPath: process.cwd(), includePatterns: ["**/*.{png,svg,jpg,jpeg,gif}"], excludePatterns: [], pretty: false }, partial.dita) });
}
exports.ditaOptionsWithDefaults = ditaOptionsWithDefaults;
function validateOptions(partial) {
    const entries = helpers_1.jsonPathEntries(partial);
    const required = [
        "dita.project.name",
        "dita.project.format",
        "dita.project.coordinator",
        "dita.deliverable.label",
        "dita.deliverable.language",
        "dita.deliverable.loio",
        "dita.deliverable.rootfile",
        "dita.deliverable.transtype",
        "dita.deliverable.version",
        "dita.deliverable.owner",
        "dita.deliverable.shortdesc",
        "dita.deliverable.outputmetas",
    ];
    const missing = required.filter(r => !entries.find(e => e[0] === r));
    if (missing.length > 0) {
        throw new Error(`The following configuration values are missing: ${missing.join(",")}`);
    }
}
function nodeToText(node) {
    const parent = node;
    if (parent.type === variable_1.NODE_TYPE_VARIABLE &&
        parent.resolvedValue !== undefined)
        return String(parent.resolvedValue);
    if (parent.value)
        return String(parent.value);
    if (parent.children)
        return parent.children.map(nodeToText).join("");
    return "";
}
exports.nodeToText = nodeToText;
function isTopicRef(topic) {
    return Object.getOwnPropertyDescriptor(topic, "href") !== undefined;
}
exports.isTopicRef = isTopicRef;
/**
 * Create a ZIP for upload to the UACP based on local files.
 */
class DitaConverter {
    constructor(git = simple_git_1.default()) {
        this.git = git;
    }
    getGitLog(projectPath, nav) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const gitLog = [];
            for (const navEntry of nav) {
                // eslint-disable-next-line no-await-in-loop
                gitLog.push(...(yield this.getGitLog(projectPath, navEntry.children)));
                if (!__1.isReference(navEntry))
                    continue;
                const pathRelativeToCwd = path_1.join(projectPath, navEntry.path);
                let simpleGitLog;
                try {
                    // eslint-disable-next-line no-await-in-loop
                    simpleGitLog = yield this.git.log({
                        file: pathRelativeToCwd,
                        strictDate: false,
                    });
                }
                catch (error) {
                    if (error.message.indexOf("unknown revision or path not in the working tree") === -1) {
                        throw error;
                    }
                    else
                        throw new Error(`Unable to load git log for '${pathRelativeToCwd}'. Does it exist?`);
                }
                if (simpleGitLog.all.length === 0)
                    throw new Error(`Unable to load git log for '${pathRelativeToCwd}'. Is it committed?`);
                const earliest = simpleGitLog.all[Math.max(simpleGitLog.all.length - 1, 0)];
                gitLog.push({
                    author: earliest.author_email,
                    lastmodifiedby: simpleGitLog.latest.author_email,
                    lastmodified: simpleGitLog.latest.date,
                    href: navEntry.path,
                });
            }
            return gitLog;
        });
    }
    getFileMetadata(fileLog, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const path = options.path;
            const fileMetaIndex = (yield Promise.all(fileLog
                .map((l) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const filePath = path_1.join(path, l.href);
                const extractor = this.extractor();
                const processor = remark().use(frontmatter, ["yaml", "toml"]).use(extractor.rule);
                yield processor.process(vfile({
                    contents: yield readFile(filePath, "utf-8"),
                    path: filePath,
                }));
                const ref = Object.assign(Object.assign(Object.assign({}, extractor.meta), l), { refs: [] });
                if (options.dita.editBase !== undefined) {
                    ref.format = new url_1.URL(l.href, options.dita.editBase).href;
                }
                return ref;
            }))))
                .reduce((acc, ref) => {
                acc[ref.href] = ref;
                return acc;
            }, {});
            return fileMetaIndex;
        });
    }
    getMostRecentModification(fileLog) {
        return fileLog.reduce((acc, f) => {
            if (acc.lastmodified > f.lastmodified)
                return acc;
            return f;
        });
    }
    getTopicReferences(nav, fileMetaIndex) {
        return nav.map(navEntry => {
            const defaults = {
                refs: [],
                label: "Unknown",
            };
            if (__1.isReference(navEntry)) {
                const meta = fileMetaIndex[navEntry.path];
                if (!meta)
                    throw new Error(`Missing file metadata for ${navEntry.path}`);
                if (navEntry.title)
                    meta.label = navEntry.title;
                return Object.assign(Object.assign(Object.assign({}, defaults), meta), { href: navEntry.path, refs: this.getTopicReferences(navEntry.children, fileMetaIndex) });
            }
            return {
                label: navEntry.title,
                refs: this.getTopicReferences(navEntry.children, fileMetaIndex),
            };
        });
    }
    /**
     * Filters external links and files matches by excludePatterns from the nav.
     *
     * @param {NavEntry[]} nav Raw nav
     * @param {string[]} excludePatterns Glob patterns to exclude
     * @returns {NavEntry[]} Filtered nav
     */
    filterNav(nav, excludePatterns) {
        return nav.filter(navEntry => {
            if (__1.isReference(navEntry)) {
                return !(navEntry.path.startsWith("http") || excludePatterns.find((p) => {
                    return minimatch(navEntry.path, p);
                }));
            }
            navEntry.children = this.filterNav(navEntry.children, excludePatterns);
            return navEntry.children.length !== 0;
        });
    }
    metadata(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const options = ditaOptionsWithDefaults(opts);
            let frameworkPlugin = plugin_1.mkdocsPlugin;
            if (options.dita.frameworkPlugin !== undefined) {
                const lookupPaths = [
                    ...module.paths,
                    process.cwd(),
                ];
                try {
                    const pluginPath = require.resolve(options.dita.frameworkPlugin, {
                        paths: lookupPaths,
                    });
                    frameworkPlugin = require(pluginPath);
                    if (typeof frameworkPlugin !== "function")
                        throw new Error(`'${options.dita.frameworkPlugin}' does not appear to be a valid framework plugin`);
                }
                catch (error) {
                    if (error.code === "MODULE_NOT_FOUND")
                        throw new Error(`Framework plugin '${options.dita.frameworkPlugin}' not found in ${lookupPaths.join(",")}`);
                    throw error;
                }
            }
            const rawNav = yield frameworkPlugin(options);
            validateOptions(options);
            log("Generating metadata");
            const nav = this.filterNav(rawNav, options.dita.excludePatterns);
            log("Filtered nav");
            const gitLog = yield this.getGitLog(options.path, nav);
            log(`Read git log for ${gitLog.length} entries`);
            const fileMetaIndex = yield this.getFileMetadata(gitLog, options);
            log("Assembled file metadata");
            const mostRecentModification = this.getMostRecentModification(gitLog);
            const refs = this.getTopicReferences(nav, fileMetaIndex);
            log("Mapped topic references");
            if (refs.length === 0) {
                throw new Error(`No files found in ${options.path}.`);
            }
            return {
                meta: {
                    project: Object.assign({}, options.dita.project),
                    deliverable: Object.assign(Object.assign({}, options.dita.deliverable), { buildname: process.env.BUILD_NUMBER || options.dita.deliverable.buildname || "0", lastmodified: mostRecentModification.lastmodified, lastmodifiedby: mostRecentModification.lastmodifiedby }),
                },
                mapref: {
                    label: options.dita.deliverable.label,
                    refs,
                },
            };
        });
    }
    metadataXml(metadata, pretty = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            /* eslint-disable indent */
            let tree = builder
                .create("metadata", {
                encoding: "UTF-8",
            })
                // Project Meta
                .ele("meta")
                .ele("project", metadata.meta.project).up()
                .ele("deliverable", Object.assign(Object.assign({}, metadata.meta.deliverable), { outputmetas: undefined }))
                .ele("outputmetas");
            for (const outputmeta of metadata.meta.deliverable.outputmetas) {
                tree = tree.ele("outputmeta");
                for (const param of outputmeta.outputmeta) {
                    tree = tree.ele("param", param).up();
                }
                tree = tree.up();
            }
            // Topicrefs
            tree = tree.up().up().up()
                .ele("mapref", Object.assign(Object.assign({}, metadata.mapref), { refs: undefined }));
            for (const topicref of metadata.mapref.refs) {
                tree = topics(tree, topicref).up();
            }
            function topics(tree, ref) {
                const data = Object.assign({}, ref);
                delete data.refs;
                if (Object.getOwnPropertyDescriptor(ref, "href")) {
                    tree = tree.element("topicref", data);
                }
                else if (ref.refs.length > 0) {
                    tree = tree.element("topichead", data);
                }
                for (const subref of ref.refs) {
                    topics(tree, subref).up();
                }
                return tree;
            }
            const xml = tree.end({ pretty: pretty });
            /* eslint-enable indent */
            return xml;
        });
    }
    ditaZip(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const metadata = yield this.metadata(opts);
            const options = ditaOptionsWithDefaults(opts);
            log("Assembled metadata");
            const metadataXml = yield this.metadataXml(metadata, opts.dita.pretty);
            log("Generated metadata.xml");
            try {
                yield mkdir(options.dita.outputPath, { recursive: true });
            }
            catch (error) {
                if (error.code !== "EEXIST")
                    throw error;
            }
            const outputStream = fs_1.createWriteStream(path_1.join(options.dita.outputPath, opts.dita.deliverable.rootfile));
            const archive = archiver("zip");
            archive.pipe(outputStream);
            function append(ref) {
                if (isTopicRef(ref))
                    archive.file(path_1.join(options.path, ref.href), { name: ref.href });
                ref.refs.forEach(append);
            }
            archive.append(metadataXml, { name: "metadata.xml" });
            append(metadata.mapref);
            options.dita.includePatterns.forEach(p => archive.glob(p, {
                cwd: options.path,
                ignore: options.dita.excludePatterns,
            }));
            log("Appended files to archive");
            return new Promise((resolve, reject) => {
                outputStream.on("close", resolve);
                outputStream.on("end", resolve);
                outputStream.on("error", reject);
                outputStream.on("warning", reject);
                archive.finalize();
                log("Finalized archive");
            });
        });
    }
    /**
     * Creates a unifiedJS rule that extracts headings and DITA types from Markdown document sources.
     * Supports both Headings (h1) and Frontmatter (title, dita.type). Frontmatter takes precedence.
     *
     * @returns Holder including the rule and the extracted meta info. Meta info will be available after the rule was invoked.
     */
    extractor() {
        const meta = {
            label: "",
            type: "concept",
        };
        return {
            meta,
            rule: rule("md:dita", function (tree, file) {
                var _a;
                meta.label = title_case_1.titleCase(((_a = file.stem) === null || _a === void 0 ? void 0 : _a.replace(/\W/g, " ")) || meta.label);
                visit(tree, "heading", (node) => {
                    if (generated(node) || node.depth !== 1)
                        return;
                    meta.label = nodeToText(node);
                });
                visit(tree, "yaml", (node) => {
                    if (generated(node))
                        return;
                    const yaml = YAML.parse(String(node.value));
                    meta.type = yaml[DitaConverter.FRONTMATTER_TYPE] || meta.type;
                    meta.label = yaml[DitaConverter.FRONTMATTER_TITLE] || meta.label;
                });
            }),
        };
    }
}
exports.DitaConverter = DitaConverter;
DitaConverter.FRONTMATTER_TYPE = "dita.type";
DitaConverter.FRONTMATTER_TITLE = "title";
//# sourceMappingURL=dita.js.map