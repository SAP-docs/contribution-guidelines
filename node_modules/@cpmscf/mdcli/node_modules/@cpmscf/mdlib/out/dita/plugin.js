"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mkdocsPlugin = void 0;
const tslib_1 = require("tslib");
const __1 = require("..");
const path_1 = require("path");
const { stat } = require("fs").promises;
exports.mkdocsPlugin = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const config = yield __1.loadMkdocsConfig(options);
    const deliverable = options.dita.deliverable;
    const docsDir = path_1.join(options.path, config.docs_dir);
    try {
        yield stat(docsDir);
    }
    catch (error) {
        if (error.code === "ENOENT")
            throw new Error(`Directory ${docsDir} does not appear to exist.`);
        else
            throw error;
    }
    // Add site label and description from mkdocs config unless already specicied
    if (config.site_name && deliverable.label === undefined)
        deliverable.label = config.site_name;
    if (config.site_description && deliverable.shortdesc === undefined)
        deliverable.shortdesc = config.site_description;
    if (config.nav.length === 0)
        throw new Error("MkDocs configuration file does not appear to have a nav.");
    const nav = transform(config.nav, config.docs_dir);
    return nav;
});
/**
* Paths in mkdocs.yml are relative to docs_dir, i.e. we need to append `docs_dir` to each path
* so that files can be resolved relative to `options.path`. Also, mkdocs has a special case where a
* topic ref may never have children.
*
* @param nav {(Topic|MkdocsReference)[]} Nav tree to transform
* @param docsDir {string} MkDocs docs dir
* @returns {NavEntry[]} Nav tree transformed to conform with library model
*/
function transform(nav, docsDir) {
    return nav.map(navEntry => {
        if (isMkdocsReference(navEntry))
            return transformMkdocsReference(navEntry, docsDir);
        return transformTopic(navEntry, docsDir);
    });
}
/**
 * Tells if this is a MkDocs topic ref, i.e. label => path mapping.
 *
 * @param navEntry {Topic | MkdocsReference} Nav entry to check
 * @returns {Boolean} `true` iff the nav entry is a file reference
 */
function isMkdocsReference(navEntry) {
    return typeof navEntry === "string" || typeof navEntry[Object.keys(navEntry)[0]] === "string";
}
/**
 * Turns the MkDocs specific file reference format to into the library format.
 * Also fixes the framework-specific file path relative to the library CWD. Paths in
 * `mkdocs.yml` are not relative to CWD, but to `docs_dir`, another directory relative to CWD.
 *
 * @param reference {MkdocsReference} The reference to transform
 * @param docsDir {string} Docs dir to prepend to paths
 * @returns {Reference} The transformed reference
 */
function transformMkdocsReference(reference, docsDir) {
    let title;
    let configuredPath;
    if (typeof reference === "string") {
        configuredPath = reference;
    }
    else {
        title = Object.keys(reference)[0];
        configuredPath = reference[title];
    }
    const path = configuredPath.startsWith("http") ?
        configuredPath : path_1.join(docsDir, configuredPath);
    return {
        children: [],
        title,
        path,
    };
}
/**
 * Fixes category titles, which may contain extra markup in the Mobile Services variant of MkDocs.
 *
 * @param topic {Topic} topic to transform
 * @param docsDir {string} Docs dir as configured in MkDocs
 * @returns {Topic} Topic with fixed title
 */
function transformTopic(topic, docsDir) {
    const title = Object.keys(topic)[0];
    const children = topic[title];
    // Our Mobile Services MkDocs has a customization where leading underscores are added
    // to denote a special (category) nav entry
    const newTitle = title.replace(/^__/, "");
    return {
        children: transform(children, docsDir),
        title: newTitle,
    };
}
//# sourceMappingURL=plugin.js.map