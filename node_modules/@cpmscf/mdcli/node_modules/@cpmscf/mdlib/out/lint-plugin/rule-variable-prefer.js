/**
 * @author D053411
 * @copyright 2020 SAP SE
 * @license SEE LICENSE IN LICENSE
 * @module titlecase
 * @fileoverview
 *   Warn when headings increment with more than 1 level at a time.
 *
 * @example {"name": "ok.md"}
 *
 *   # Alpha
 *
 *   ## Bravo
 *
 * @example {"name": "not-ok.md", "label": "input"}
 *
 *   # Charlie
 *
 *   ### Delta
 *
 * @example {"name": "not-ok.md", "label": "output"}
 *
 *   3:1-3:10: Heading levels should increment by one level at a time
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.preferVariableRule = exports.CODE_VARIABLE_PREFER = void 0;
const rule = require("unified-lint-rule");
const visit = require("unist-util-visit");
const generated = require("unist-util-generated");
const helpers_1 = require("../helpers");
const reason = "Prefer variable instead of plain text";
const shortLink = "065w";
exports.CODE_VARIABLE_PREFER = "markdown-lint:variable-prefer";
const VARIABLE_COMPARATOR = (a, b) => {
    const va = a[1];
    const vb = b[1];
    return vb.localeCompare(va);
};
function preferVariableRule(config) {
    return rule(exports.CODE_VARIABLE_PREFER, function (tree, file) {
        visit(tree, "text", visitText);
        function visitText(text) {
            if (generated(text))
                return;
            const textValue = text.value;
            const vars = helpers_1.jsonPathEntries(config.extra || {}).sort(VARIABLE_COMPARATOR);
            vars.forEach(([key, value]) => {
                const pattern = new RegExp(`\\b${value}\\b`, "g");
                let match;
                // eslint-disable-next-line no-cond-assign
                while (match = pattern.exec(textValue)) {
                    const originalContent = match[0];
                    const fixedContent = `{{ ${key} }}`;
                    const startOffset = match.index;
                    const endOffset = startOffset + originalContent.length;
                    const node = {
                        type: "text",
                        value: originalContent,
                        position: {
                            start: {
                                line: text.position.start.line,
                                column: text.position.start.column + startOffset,
                                offset: text.position.start.offset + startOffset,
                            },
                            end: {
                                line: text.position.start.line,
                                column: text.position.start.column + endOffset,
                                offset: text.position.start.offset + endOffset,
                            },
                        },
                    };
                    helpers_1.makeMessage(exports.CODE_VARIABLE_PREFER, originalContent, fixedContent, node, reason, file, shortLink);
                }
            });
        }
    });
}
exports.preferVariableRule = preferVariableRule;
//# sourceMappingURL=rule-variable-prefer.js.map