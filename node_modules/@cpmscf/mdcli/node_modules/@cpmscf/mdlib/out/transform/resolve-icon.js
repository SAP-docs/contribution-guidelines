"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveIcons = exports.PLUGIN_PYMDOWNX_EMOJI = exports.CODE_ICON_NO_UNDEF = void 0;
const tslib_1 = require("tslib");
const visit = require("unist-util-visit");
const __1 = require("..");
const { join, basename } = require("path");
const icon_1 = require("../compiler-plugin/icon");
const glob_1 = require("../glob");
exports.CODE_ICON_NO_UNDEF = "remark-lint:icon-no-undef";
exports.PLUGIN_PYMDOWNX_EMOJI = "pymdownx.emoji";
const shortLink = "065x";
const warned = {};
// https://jinja.palletsprojects.com/en/master/api/#identifier-naming
function visitIcon(ast, file, options) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const icons = [];
        const SVG_EXTENSION = ".svg";
        const customIconDirs = (_a = options.mkdocsConfig.markdown_extensions) === null || _a === void 0 ? void 0 : _a.find(plugin => plugin[exports.PLUGIN_PYMDOWNX_EMOJI] !== undefined)[exports.PLUGIN_PYMDOWNX_EMOJI].options.custom_icons;
        let iconIdPathMap = {};
        if (customIconDirs !== undefined && customIconDirs.length !== 0) {
            for (const customIconDir of customIconDirs) {
                const absoluteCustomIconDir = join(options.path, customIconDir);
                const path = join(absoluteCustomIconDir, "**", `*${SVG_EXTENSION}`);
                const batch = {};
                // eslint-disable-next-line no-await-in-loop
                (yield glob_1.globAsync(path))
                    .reduce((acc, path) => {
                    const id = basename(path.substr(absoluteCustomIconDir.length + 1).replace(/\//g, "-"), SVG_EXTENSION);
                    acc[id] = path;
                    return acc;
                }, batch);
                if (Object.keys(batch).length === 0 && !warned[path]) {
                    console.warn(`Warning: '${path}' does not appear to contain any icons.`);
                    warned[path] = true;
                }
                iconIdPathMap = Object.assign(Object.assign({}, iconIdPathMap), batch);
            }
        }
        visit(ast, icon_1.NODE_TYPE_ICON, (icon) => {
            icons.push(icon);
            return icon;
        });
        for (const icon of icons) {
            const value = String(icon.value);
            const reason = `Icon '${value}' not found in '${options.path}/{${customIconDirs}}'`;
            const iconPath = iconIdPathMap[value];
            if (iconPath === undefined) {
                __1.makeMessage(exports.CODE_ICON_NO_UNDEF, value, undefined, icon, reason, file, shortLink);
            }
            else {
                icon.path = iconPath;
            }
        }
    });
}
function resolveIcons(opts) {
    const options = Object.assign({
        path: process.cwd(),
    }, opts);
    return function () {
        const scope = this.Parser.prototype.inlineTokenizers;
        const methods = this.Parser.prototype.inlineMethods;
        scope[icon_1.NODE_TYPE_ICON] = icon_1.iconTokenizer(opts);
        if (this.Compiler) {
            this.Compiler.prototype.visitors[icon_1.NODE_TYPE_ICON] = (node) => {
                return `:${node.value}:`;
            };
        }
        // Specify order (just before `text`).
        methods.splice(methods.indexOf("text"), 0, icon_1.NODE_TYPE_ICON);
        return function (ast, vFile, next) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield visitIcon(ast, vFile, options);
                }
                catch (error) {
                    console.error(error);
                }
                if (typeof next === "function") {
                    next(null, ast, vFile);
                }
                return ast;
            });
        };
    };
}
exports.resolveIcons = resolveIcons;
//# sourceMappingURL=resolve-icon.js.map