"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TargetFinder = void 0;
const tslib_1 = require("tslib");
const path_1 = require("path");
const _1 = require(".");
const path_2 = require("path");
const rule = require("unified-lint-rule");
const visit = require("unist-util-visit");
const parse = require("remark-parse");
const stringify = require("remark-stringify");
const { readFile } = require("fs").promises;
const FILE_PROTOCOL_PREFIX = /^file:\/\/?/;
const unified = require("unified");
class TargetFinder {
    constructor(rcConf, mkdocsConfig) {
        this.targets = new Map();
        this.rcConf = rcConf;
        this.mkdocsConfig = mkdocsConfig;
    }
    /**
     * Finds the specified file, relative to `rcConf.path`.
     *
     * @param {string} filePath Path to file, relative to `rcConf.path`
     * @returns {Set<string>} Hashes found in file, or undefined if it did not exist
     */
    find(filePath) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const path = path_2.isAbsolute(filePath) ? filePath : path_2.join(this.rcConf.path, filePath);
                const fileContents = yield readFile(path, "utf-8");
                if (TargetFinder.MARKDOWN_REGEX.exec(path))
                    this.targets.set(filePath, yield this.processMarkdown(fileContents));
                else if (TargetFinder.HTML_REGEX.exec(path))
                    this.targets.set(filePath, this.processHtml(fileContents));
                else
                    this.targets.set(filePath, new Set());
                return this.targets.get(filePath);
            }
            catch (error) {
                // ENOENT --> file doesn't exist, which is what we want to check.
                if (error.code !== "ENOENT" &&
                    error.code !== "ENOTDIR")
                    throw error;
            }
        });
    }
    processMarkdown(fileContents) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { hashes, rule } = this.extractor();
            const processor = unified()
                .use(stringify)
                .use(parse)
                .use(_1.resolveVariables({
                mkdocsConfig: this.mkdocsConfig,
            }))
                .use(rule);
            yield processor.process(fileContents);
            return new Set(hashes);
        });
    }
    processHtml(fileContents) {
        const idRegex = /id="([^"]+)"/gm;
        let match;
        const hashes = new Set();
        // eslint-disable-next-line no-cond-assign
        while (match = idRegex.exec(fileContents)) {
            const hash = match[1];
            hashes.add(hash);
        }
        return hashes;
    }
    /**
     * Re-indexes the specified file.
     *
     * @param filePath Path to the file to update
     * @returns {void}
     */
    update(filePath) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.find(filePath);
        });
    }
    exists(filePath, hash) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const normalizedPath = path_1.normalize(filePath.replace(FILE_PROTOCOL_PREFIX, ""));
            const bucket = this.targets.get(normalizedPath) || (yield this.find(normalizedPath));
            if (hash)
                return Boolean(bucket === null || bucket === void 0 ? void 0 : bucket.has(hash));
            return Boolean(bucket);
        });
    }
    hashesIn(file) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.targets.get(file) || new Set();
        });
    }
    /**
     * Creates a unifiedJS rule that extracts hashes from Markdown document sources.
     *
     * @returns Holder including the rule and the extracted hashes. Hash info will be available after the rule was invoked.
     */
    extractor() {
        const hashes = [];
        return {
            hashes,
            rule: rule("md:link-targets", function (tree) {
                visit(tree, "heading", (node) => {
                    hashes.push(_1.nodeToText(node).trim()
                        .toLowerCase()
                        .replace(/[^\w\s-]/g, "")
                        .replace(/(\s|-)+/g, "-"));
                });
            }),
        };
    }
}
exports.TargetFinder = TargetFinder;
TargetFinder.MARKDOWN_REGEX = /(\.md|\.markdown)$/;
TargetFinder.HTML_REGEX = /(\.html?)$/;
//# sourceMappingURL=targets.js.map