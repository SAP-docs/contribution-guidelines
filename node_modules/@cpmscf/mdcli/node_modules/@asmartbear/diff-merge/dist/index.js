'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
// A dependency-free, type-safe difference algorithm.
// Operates on arrays of values, which just need to support the concept of equality (like strings).
// Generally tries to find minimal edits, but trades off for speed especially with longer sequences.
// Terminology:
//  "prev" -- the previous array; the "before"
//  "next" -- the next array; the "after"
// true if we're running in various environments
const is_node = typeof process !== "undefined";
const is_chrome = !is_node && typeof window !== "undefined" && "chrome" in window;
// const is_safari: boolean = !is_node && typeof window !== "undefined" && "safari" in window;
// true if we're running the V8 Javascript Engine
const is_v8 = is_node || is_chrome;
// when to use various native functions versus our own functions, depending on speeds of various environments
const should_use_native_indexof = is_v8;
// const supports_backwards_match_regex: boolean = !is_safari;
/**
 * Like Math.max(), but executes faster in some Javascript browsers and contexts.
 */
function imax(a, b) {
    return a > b ? a : b;
}
/**
 * Like Math.min(), but executes faster in some Javascript browsers and contexts.
 */
function imin(a, b) {
    return a < b ? a : b;
}
/**
 * Returns the number of characters that both strings have in common, or 0 if none or at least one is null or undefined.
 *
 * Contains a few optimizations (that benchmarks indicate are, in fact, useful), and is Unicode-safe.
 */
function getCommonPrefixLength(a, b) {
    if (!a || !b || a.charAt(0) !== b.charAt(0))
        return 0; // trivial, quick cases
    if (a.charAt(1) !== b.charAt(1))
        return 1; // since both strings are non-empty, this is valid, and quick in the common case that there's nothing else
    let max = a.length < b.length ? a.length : b.length;
    for (let k = 2; k < max; ++k) {
        if (a.charAt(k) !== b.charAt(k)) {
            return k;
        }
    }
    return max;
}
exports.getCommonPrefixLength = getCommonPrefixLength;
/**
 * Holds an array with offset and length, so we can create a pseudo-array "view" into an array without
 * making large-array copies or allocations.  The "end" is inclusive!
 */
class ArrayView {
    constructor(a, start = 0, end = a.length - 1) {
        this.a = a;
        this.start = start;
        this.end = end;
        // nothing else to do
    }
    static createEmpty() {
        return new ArrayView([], 0, -1); // FIXME: share single empty array object since it's immutable?
    }
    /**
     * The number of elements in this view.
     */
    get length() {
        return this.end - this.start + 1;
    }
    /**
     * True if this view is empty, i.e. represents the empty array, and has length 0.
     */
    get empty() {
        return this.end < this.start;
    }
    /**
     * Like Array.indexOf(), but includes start (relative to the actual start of the underlying array) and end (inclusive
     * and relative to the actual underlying array).
     */
    indexOf(target, start = this.start, end = this.end) {
        // In most browsers, Array#indexOf() is very slow. Therefore, we scan it ourselves.
        // Plus Array#indexOf() doesn't understand the end of the array, which we could correct for, but it's slower anyway.
        // Benchmark: https://run.perf.zone/view/for-vs-while-vs-indexof-1000-strings-1516293164213
        // The native indexOf() can be faster, even though it can do "extra work" by running off the end of the array.
        if (should_use_native_indexof) {
            const result = this.a.indexOf(target, start);
            return result > end ? -1 : result;
        }
        // Manual scan.
        const a = this.a;
        for (let k = start; k <= end; ++k) {
            if (a[k] === target) {
                return k;
            }
        }
        return -1;
    }
    /**
     * Same behavior as String#indexOf: Find another ArrayView as a consecutive substring on this array, returning the
     * (absolute) index of the first such position, or -1 if not found.
     */
    indexOfSubstring(target, start = this.start, end = this.end) {
        // Trivial cases
        if (target.empty)
            return 0;
        if (this.empty)
            return -1;
        // The following implementation is fine if the underlying array is short, but if it's long, it would be worth computing
        // a table for something like KMP or Boyer-Moore searching.  Be sure to add lots more unit tests before doing that though!
        const target_first_element = target.a[target.start]; // cache this one, since we're scanning for it first
        const target_length = target.length;
        if (target_length === 1)
            return this.indexOf(target_first_element, start, end); // a faster algorithm in the case of finding a single element
        const a = this.a;
        end = imin(end, this.end - target_length + 1); // don't run off the end of our array looking for the target
        for (let k = start; k <= end; ++k) { // if the target is longer than us, this loop will end trivially, so we don't need to check that case separately
            if (a[k] === target_first_element) {
                let matched = true;
                for (let len = 1; len < target_length; ++len) {
                    if (a[k + len] !== target.a[target.start + len]) {
                        matched = false;
                        break;
                    }
                }
                if (matched) {
                    return k;
                }
            }
        }
        return -1;
    }
    /**
     * Creates a copy of this subsection of the array, which is therefore modifable, and allocates memory.
     */
    getCopy() {
        /**
         * Creates shallow copy of an array, using whatever is fastest in the current environment.
         * Ref: https://jsperf.com/new-array-vs-splice-vs-slice/31
         *
         * In Safari desktop it's fastest to while-loop; slice is 11% slower.
         * In Chrome desktop it's fastest to slice().
         * In Firefox desktop it's an order of magnitude faster to slice().
         */
        return this.a.slice(this.start, this.end + 1);
    }
    /**
     * Like Array.forEach(), but on this view of the array, and more restrictions on the callback function.
     */
    forEach(f) {
        const a = this.a;
        const end = this.end;
        for (let k = this.start; k <= end; ++k) { // because of starting and ending
            f(a[k]);
        }
    }
    /**
     * Like Array.map(), but on this view of the array, and more restrictions on the callback function.
     */
    map(f) {
        const result = [];
        const a = this.a;
        const end = this.end;
        for (let k = this.start; k <= end; ++k) { // because of starting and ending
            result[result.length] = f(a[k]);
        }
        return result;
    }
    /**
     * Like Array.map(), but on this view of the array, and the mapping function converts to a string.
     */
    mapToString(f) {
        const result = [];
        const a = this.a;
        const end = this.end;
        for (let k = this.start; k <= end; ++k) { // because of starting and ending
            result[result.length] = f(a[k]);
        }
        return result;
    }
    /**
     * Pushes all of the elements from this view onto the end of the given array.
     */
    pushAll(arry) {
        const a = this.a;
        const end = this.end;
        for (let k = this.start; k <= end; ++k) {
            arry[arry.length] = a[k];
        }
    }
    /**
     * Retrieves an element from the array, relative to the start of this view.
     */
    getElement(relative_index) {
        return this.a[this.start + relative_index];
    }
    /**
     * Return an ArrayView that is a subsequence, starting at an offset relative to `this,` and with a given length.
     * If the result would be identical to `this`, then `this` itself is returned without allocating a new view.
     * If length is missing, the subsequence goes to the end.
     */
    getSubsequence(relative_start, relative_length) {
        if (relative_length === undefined) {
            if (relative_start === 0) { // save an allocation if we can just return ourselves
                return this;
            }
            return new ArrayView(this.a, this.start + relative_start, this.end); // end is fixed, so no need to compute length and so forth
        }
        if (relative_length <= 0) { // clamp
            relative_length = 0;
        }
        if (relative_start == 0 && relative_length == this.length) { // happens to be identical to self
            return this;
        }
        const offset = this.start + relative_start; // slight optimization, since we use it twice
        return new ArrayView(this.a, offset, offset + relative_length - 1);
    }
    /**
     * Gets an array in reverse order, just the elements inside this view, as a new view.
     * This allocates memory.
     */
    getReverse() {
        return new ArrayView(this.getCopy().reverse());
    }
    toString() {
        return this.getCopy().join('');
    }
    /**
     * True if this subsequence is equal to the other subsequence, false otherwise.
     */
    equals(that) {
        // We intentionally use duplicate objects, e.g. for "equality" Edits, so if we're lucky, this super-fast check short-circuits "true"
        if (this === that)
            return true;
        // Length-check short-circuits "false" in many cases
        const len = this.length;
        if (len !== that.length)
            return false;
        // Reuse other code to compare all characters in both arrays
        return this.getLengthOfCommonPrefix(that) == len;
    }
    /**
     * Returns -1, 0, or 1, indicating whether `this` is less, equal, or greater than `that`, comparing like strings, e.g. one element at a time,
     * returning the answer if they're unequal, and if the shorter is equal to the prefix of the latter, the shorter is deemed smaller.
     */
    compare(that) {
        const a = this.a;
        const b = that.a;
        const a_end = this.end;
        const b_end = that.end;
        let ai = this.start;
        let bi = that.start;
        while (ai <= a_end && bi <= b_end) {
            const a_el = a[ai];
            const b_el = b[bi];
            if (a_el < b_el)
                return -1;
            if (a_el > b_el)
                return 1;
            ++ai;
            ++bi;
        }
        return ai <= a_end ? 1 : bi <= b_end ? -1 : 0;
    }
    /**
     * Concatenates a sequence onto this one, NOT changing the current one, but rather returning a new result.
     * This is akin to Array#concat() with just one parameter.
     * Various optimizations prevent allocating memory whenever possible.
     */
    concat(that) {
        // Trivial cases with no allocations; yay!
        if (this.empty)
            return that;
        if (that.empty)
            return this;
        // If exactly consecutive, we can get away with a new view on the existing underlying array.
        if (this.a === that.a && this.end + 1 === that.start) {
            return new ArrayView(this.a, this.start, that.end);
        }
        // We have to create a new array.
        const result = this.getCopy();
        that.pushAll(result);
        return new ArrayView(result);
    }
    /**
     * Returns the number of elements that are common to the first elements in both arrays.
     * Each array can be any size, including empty, but cannot be null or undefined.
     */
    getLengthOfCommonPrefix(that) {
        const a = this.a;
        const b = that.a;
        const a_end = this.end;
        const b_end = that.end;
        let ai = this.start;
        let bi = that.start;
        let n = 0;
        while (ai <= a_end && bi <= b_end) {
            if (a[ai] !== b[bi]) {
                break;
            }
            ++n;
            ++ai;
            ++bi;
        }
        return n;
    }
    /**
     * Returns the number of elements that are common to the last elements in both arrays.
     * Each array can be any size, including empty, but cannot be null or undefined.
     */
    getLengthOfCommonSuffix(that) {
        const a = this.a;
        const b = that.a;
        const a_start = this.start;
        const b_start = that.start;
        let ai = this.end;
        let bi = that.end;
        let n = 0;
        while (ai >= a_start && bi >= b_start) {
            if (a[ai] !== b[bi]) {
                break;
            }
            ++n;
            --ai;
            --bi;
        }
        return n;
    }
    /**
     * Find the longest length L of a suffix of `this` which overlaps with a prefix of `that` also of length L.
     * Each array can be any size, including empty, but not null or undefined.  Returns 0 if there is no commonality.
     */
    getLengthOfOverlapAtMyEnd(that) {
        // FIXME: Better algorithm, maybe something like taking the first char of B, and scanning in A for it.
        // Anything in A that matches the whole prefix/suffix has to start by matching this way, but we reuse a fast algorithm for it.
        const a = this.a;
        const b = that.a;
        const a_start = this.start;
        const b_start = that.start;
        const a_end = this.end;
        const b_end = that.end;
        for (let n_inclusive = imin(a_end - a_start, b_end - b_start); n_inclusive >= 0; --n_inclusive) {
            let matches = true;
            for (let k = n_inclusive; k >= 0; --k) {
                if (a[a_end - k] !== b[b_start + n_inclusive - k]) {
                    matches = false;
                    break;
                }
            }
            if (matches) {
                return n_inclusive + 1;
            }
        }
        return 0;
    }
    /**
     * Returns a pair of ArrayViews containing the longest common substring in `this` and `that` respectively.
     * Both views in the pair will be empty if there's no common substring.
     *
     * This particular algorithm is slow -- O(N*M) -- but always finds the right answer, is simple, it approaches
     * O(N) if the longest substring is long, and it uses only O(1) additional memory.
     * It uses a few techniques to speed up, for finding the first element of a substring,
     * and by anticipating that a found-substring might be extended in-place to speed up the best-so-far length.
     * In short, the N-loop is slow but the M-loop is fast, and further, it orders strings such that N <= M.
     */
    static getLongestCommonSubstringGrowingLinearScan(ths, tht) {
        // a is shorter, b is longer
        // Put the shorter string on the outer loop for faster execution.
        // As a special case, when sequence length is longer than the shorter string, it will automatically terminate; not so if longer were on the outside.
        // As a special case, if the shorter string is embedded completely in the longer, we'll find that very quickly and terminate.
        const this_is_shorter = ths.length <= tht.length;
        const shorter = (this_is_shorter ? ths : tht);
        const longer = (this_is_shorter ? tht : ths);
        const a = shorter.a;
        const b = longer.a;
        const a_start = shorter.start;
        const b_start = longer.start;
        const a_end_p1 = shorter.end + 1;
        const b_end_p1 = longer.end + 1;
        let subsequence_len = 1; // the current length of the subsequence that we're scanning for
        let best_a_start = 0;
        let best_b_start = 0;
        let best_length = 0;
        for (let ai = a_start; ai + subsequence_len <= a_end_p1;) {
            // Does the current subsequence in a, appear anywhere in b?
            // If yes, place the index in `bi_found`, else that will be -1 at the end of the loop.
            let bi_found = -1;
            const bi_end_search = b_end_p1 - subsequence_len; // don't scan off the end of the array, given the substring length we will require
            const target = a[ai]; // speedup: cache the target value
            let bi = b_start;
            while ((bi = longer.indexOf(target, bi, bi_end_search)) >= 0) {
                let found = true;
                for (let k = subsequence_len; --k > 0;) { // don't have to check when k==0 because the equality test above already did that
                    if (a[ai + k] !== b[bi + k]) {
                        found = false;
                        break;
                    }
                }
                if (found) {
                    bi_found = bi;
                    break;
                }
                ++bi;
            }
            // If we found something, save it as "best so far," and increment the length and try again,
            // otherwise keep the length the same and try the next index.
            if (bi_found >= 0) {
                // Attempt to extend the match we found.  Don't run off the end of the array!
                for (let k = subsequence_len; ai + k < a_end_p1 && bi_found + k < b_end_p1 && a[ai + k] === b[bi_found + k];) {
                    subsequence_len = ++k; // match!  new length, and increment our test-length in k
                }
                // Save this as the "best so far," and continue with the next-larger subsequence length to beat it
                best_a_start = ai;
                best_b_start = bi_found;
                best_length = subsequence_len;
                ++subsequence_len;
            }
            else {
                ++ai; // next!
            }
        }
        const result = [
            new ArrayView(a, best_a_start, best_a_start + best_length - 1),
            new ArrayView(b, best_b_start, best_b_start + best_length - 1),
        ];
        if (!this_is_shorter) {
            result.reverse();
        }
        return result;
    }
    /**
     * Returns a pair of ArrayViews containing the longest common substring in `this` and `that` respectively.
     * Both views in the pair will be empty if there's no common substring.
     *
     * This algorithm uses an "optimistic" method, in which if there are long common substrings (relative to the
     * shortest string), it will be found quickly, in O(M) comparisons.  It is still O(NM) in the worst case,
     * which is the lack of a common substring, or a common of 1 character.
     */
    static getLongestCommonSubstringOptimisticBisect(ths, tht) {
        // The shorter string must come first.  If not, compute the converse, then reverse the order of the result.
        const is_swapped = ths.length > tht.length;
        const short = is_swapped ? tht : ths;
        const long = is_swapped ? ths : tht;
        // console.log(`LCS OB: [${short.toString()}] -> [${long.toString()}]`);
        // Load up the remaining variables
        const short_a = short.a;
        const long_a = long.a;
        const short_start = short.start;
        const long_start = long.start;
        const short_end = short.end;
        const long_end = long.end;
        const f_floor = Math.floor;
        // Initialize the state of the "best so far"
        // best x, y starting locations, and best length
        let best_so_far_x = -1;
        let best_so_far_y = -1;
        let best_so_far_len = 0;
        // Initialize bisection scanning queue.  Must use a queue for scanning, to do breadth-first, attempting to
        // find the longest strings as soon as possible.  This is the "optimism" of finding something long, and cuts off
        // all smaller scans in case we do.  The format is [min,max] inclusive, the interval in the y direction, the smaller string.
        const scan_queue = [[short_start, short_end]];
        while (scan_queue.length > 0) {
            // Dequeue the next interval to scan, and leave if it's too small to result in a longer substring than we've already found.
            const [y_min, y_max] = scan_queue.shift();
            const interval_len = y_max - y_min + 1;
            if (interval_len <= best_so_far_len) { // once we start scanning things that are smaller than best-so-far, we can stop; all else enqueued are equal or smaller
                continue;
            }
            // Bisect the interval, thus finding all substrings that are at least half the lengths of this interval.
            const y = y_min + f_floor(interval_len / 2);
            const target = short_a[y];
            let x = long_start;
            // console.log(`  OB horizontal: scan '${target}' at y=${y}∈[${y_min},${y_max}], x∈[${long_start},${long_end}], seeking S > ${best_so_far_len}`);
            while ((x = long.indexOf(target, x, long_end)) >= 0) { // scan, using indexOf() to leap to the next match
                // console.log(`    HIT: (${x},${y})`);
                // Find the head and tail of the snake in both strings, by extending in both directions
                let x_snake_start = x;
                let y_snake_start = y;
                let snake_length = 1;
                while (y_snake_start > short_start && x_snake_start > long_start && short_a[y_snake_start - 1] === long_a[x_snake_start - 1]) { // check backward, and track that starting point
                    ++snake_length;
                    --x_snake_start;
                    --y_snake_start;
                }
                const max_long_length = long_end - x_snake_start;
                const max_short_length = short_end - y_snake_start;
                const max_snake_length = max_long_length < max_short_length ? max_long_length : max_short_length; // the snake cannot be longer than this, since the head is fixed
                while (snake_length <= max_snake_length && short_a[y_snake_start + snake_length] === long_a[x_snake_start + snake_length]) {
                    ++snake_length;
                }
                // console.log(`      HIT RESULT: (${x_snake_start},${y_snake_start}) for ${snake_length}`);
                // If this is the biggest snake we've seen so far, record it.
                if (snake_length > best_so_far_len) {
                    // console.log(`      LONGEST: (${x_snake_start},${y_snake_start}) for ${snake_length}`);
                    best_so_far_x = x_snake_start;
                    best_so_far_y = y_snake_start;
                    best_so_far_len = snake_length;
                }
                // Next time through, start scanning at the following character
                ++x;
            }
            // Enqueue the recursive intervals
            if (y - y_min > best_so_far_len) { // we'll check when we pop too, but might as well not even make an array and push and pop; nearly 2x's performance!
                scan_queue.push([y_min, y - 1]);
            }
            if (y_max - y > best_so_far_len) { // we'll check when we pop too, but might as well not even make an array and push and pop; nearly 2x's performance!
                scan_queue.push([y + 1, y_max]);
            }
        }
        // If nothing found, return an empty result
        if (best_so_far_len == 0) {
            const empty = ArrayView.createEmpty();
            return [empty, empty];
        }
        // Return the result in the form of ArrayViews.
        // Reorder them based on whether we originally swapped them for the short/long requirement.
        const short_result = new ArrayView(short_a, best_so_far_y, best_so_far_y + best_so_far_len - 1);
        const long_result = new ArrayView(long_a, best_so_far_x, best_so_far_x + best_so_far_len - 1);
        return is_swapped ? [long_result, short_result] : [short_result, long_result];
    }
    /**
     * Finds the longest common substring between two strings, returning the offset in the two input strings,
     * and the length.
     *
     * This algorithm uses an "optimistic" method, in which if there are long common substrings (relative to the
     * shortest string), it will be found quickly, in O(M) comparisons.  It is still O(NM) in the worst case,
     * which is the lack of a common substring, or a common of 1 character.
     */
    static getLongestCommonSubstringOptimisticBisectString(a, b) {
        // The shorter string must come first.  If not, compute the converse, then reverse the order of the result.
        const is_swapped = a.length > b.length;
        const short_a = is_swapped ? b : a;
        const long_a = is_swapped ? a : b;
        const f_floor = Math.floor;
        // console.log(`LCS OB: [${short_a}] -> [${long_a}]`);
        // Load up the remaining variables
        const short_end = short_a.length - 1;
        const long_end = long_a.length - 1;
        // Initialize the state of the "best so far"
        // best x, y starting locations, and best length
        let best_so_far_x = -1;
        let best_so_far_y = -1;
        let best_so_far_len = 0;
        // Initialize bisection scanning queue.  Must use a queue for scanning, to do breadth-first, attempting to
        // find the longest strings as soon as possible.  This is the "optimism" of finding something long, and cuts off
        // all smaller scans in case we do.  The format is [min,max] inclusive, the interval in the y direction, the smaller string.
        const scan_queue = [[0, short_end]];
        while (scan_queue.length > 0) {
            // Dequeue the next interval to scan, and leave if it's too small to result in a longer substring than we've already found.
            const [y_min, y_max] = scan_queue.shift();
            const interval_len = y_max - y_min + 1;
            if (interval_len <= best_so_far_len) { // once we start scanning things that are smaller than best-so-far, we can stop; all else enqueued are equal or smaller
                continue;
            }
            // Bisect the interval, thus finding all substrings that are at least half the lengths of this interval.
            const y = y_min + f_floor(interval_len / 2);
            const target = short_a.charAt(y);
            let x = 0;
            // console.log(`  OB horizontal: scan '${target}' at y=${y}∈[${y_min},${y_max}], x∈[${long_start},${long_end}], seeking S > ${best_so_far_len}`);
            while ((x = long_a.indexOf(target, x)) >= 0) { // scan, using indexOf() to efficiently leap to the next match
                // console.log(`    HIT: (${x},${y})`);
                // Find the head and tail of the snake in both strings, by extending in both directions
                let x_snake_start = x;
                let y_snake_start = y;
                let snake_length = 1;
                while (y_snake_start > 0 && x_snake_start > 0 && short_a.charAt(y_snake_start - 1) === long_a.charAt(x_snake_start - 1)) { // check backward, and track that starting point
                    ++snake_length;
                    --x_snake_start;
                    --y_snake_start;
                }
                const max_long_length = long_end - x_snake_start;
                const max_short_length = short_end - y_snake_start;
                const max_snake_length = max_long_length < max_short_length ? max_long_length : max_short_length; // the snake cannot be longer than this, since the head is fixed
                while (snake_length <= max_snake_length && short_a.charAt(y_snake_start + snake_length) === long_a.charAt(x_snake_start + snake_length)) {
                    ++snake_length;
                }
                // console.log(`      HIT RESULT: (${x_snake_start},${y_snake_start}) for ${snake_length}`);
                // If this is the biggest snake we've seen so far, record it.
                if (snake_length > best_so_far_len) {
                    // console.log(`      LONGEST: (${x_snake_start},${y_snake_start}) for ${snake_length}`);
                    best_so_far_x = x_snake_start;
                    best_so_far_y = y_snake_start;
                    best_so_far_len = snake_length;
                }
                // Next time through, start scanning at the following character
                ++x;
            }
            // Enqueue the recursive intervals
            if (y - y_min > best_so_far_len) { // we'll check when we pop too, but might as well not even make an array and push and pop; nearly 2x's performance!
                scan_queue.push([y_min, y - 1]);
            }
            if (y_max - y > best_so_far_len) { // we'll check when we pop too, but might as well not even make an array and push and pop; nearly 2x's performance!
                scan_queue.push([y + 1, y_max]);
            }
        }
        // Return the result, making sure to swap back a/b for short/long
        return {
            a_offset: is_swapped ? best_so_far_x : best_so_far_y,
            b_offset: is_swapped ? best_so_far_y : best_so_far_x,
            len: best_so_far_len,
        };
    }
    /**
     * Returns the index coordinates of the middle of the longest common subsequence between the two arrays.
     * The longest subsequence is the longest set of ordered (but not necessarily consecutive) equal elements
     * from both arrays.  The middle is often but not always along a common substring.  Even when it is a common
     * substring, it is often not the globally-longest common substring.
     *
     * The index is relative to the start of each ArrayView, not relative to the absolute position inside the
     * underlying array.
     *
     * If there is no common subsequence whatsoever, `null` is returned.
     */
    getLongestCommonSubsequenceMiddleMyers(that) {
        // HT to fraser@google.com (Neil Fraser); adapted this algorithm from his diff-merge-patch Javascript code.
        // console.log(`LCS Myers: [${this.toString()}] -> [${that.toString()}]`);
        const a = this.a;
        const b = that.a;
        const a_start = this.start;
        const b_start = that.start;
        // Cache the text lengths to prevent multiple calls.
        let text1_length = this.length;
        let text2_length = that.length;
        let max_d = Math.ceil((text1_length + text2_length) / 2);
        let v_offset = max_d;
        let v_length = 2 * max_d;
        let v1 = new Array(v_length);
        let v2 = new Array(v_length);
        // Setting all elements to -1 is faster in Chrome & Firefox than mixing
        // integers and undefined.
        for (let i = 0; i < v_length; i++) {
            v1[i] = -1;
            v2[i] = -1;
        }
        v1[v_offset + 1] = 0;
        v2[v_offset + 1] = 0;
        let delta = text1_length - text2_length;
        // If the total number of characters is odd, then the front path will collide
        // with the reverse path.
        let front = (delta % 2 != 0);
        // Offsets for start and end of k loop.
        // Prevents mapping of space beyond the grid.
        let k1start = 0;
        let k1end = 0;
        let k2start = 0;
        let k2end = 0;
        for (let d = 0; d < max_d; d++) {
            // Walk the front path one step.
            for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
                let k1_offset = v_offset + k1;
                let x1;
                if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
                    x1 = v1[k1_offset + 1];
                }
                else {
                    x1 = v1[k1_offset - 1] + 1;
                }
                let y1 = x1 - k1;
                // let snake_length = 0;
                while (x1 < text1_length && y1 < text2_length && a[a_start + x1] === b[b_start + y1]) {
                    ++x1;
                    ++y1;
                    // ++snake_length;
                }
                v1[k1_offset] = x1;
                if (x1 > text1_length) {
                    // Ran off the right of the graph.
                    k1end += 2;
                }
                else if (y1 > text2_length) {
                    // Ran off the bottom of the graph.
                    k1start += 2;
                }
                else if (front) {
                    let k2_offset = v_offset + delta - k1;
                    if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
                        // Mirror x2 onto top-left coordinate system.
                        const x2 = text1_length - v2[k2_offset];
                        // const k2 = k2_offset - v_offset;
                        // const y2 = text2_length - (v2[k2_offset] - k2);
                        if (x1 >= x2) {
                            // Overlap detected.  Return the head of the snake that we might have just traversed
                            // console.log(`>>> LCS from forwards, S=${snake_length}, (x1,y2)=(${x1},${y1}) vs (x2,y2)=(${x2},${y2})`);
                            return [x1, y1];
                        }
                    }
                }
            }
            // Walk the reverse path one step.
            for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
                let k2_offset = v_offset + k2;
                let x2;
                if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
                    x2 = v2[k2_offset + 1];
                }
                else {
                    x2 = v2[k2_offset - 1] + 1;
                }
                let y2 = x2 - k2;
                // let snake_length = 0;
                while (x2 < text1_length && y2 < text2_length && a[a_start + text1_length - x2 - 1] === b[b_start + text2_length - y2 - 1]) {
                    ++x2;
                    ++y2;
                    // ++snake_length;
                }
                v2[k2_offset] = x2;
                if (x2 > text1_length) {
                    // Ran off the left of the graph.
                    k2end += 2;
                }
                else if (y2 > text2_length) {
                    // Ran off the top of the graph.
                    k2start += 2;
                }
                else if (!front) {
                    let k1_offset = v_offset + delta - k2;
                    if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
                        const x1 = v1[k1_offset];
                        const y1 = v_offset + x1 - k1_offset;
                        // Mirror x2 onto top-left coordinate system.
                        x2 = text1_length - x2;
                        if (x1 >= x2) {
                            // Overlap detected.  If there was a snake, we already traversed it, and these coordinates are the head
                            // console.log(`>>> LCS from backwards, S=${snake_length}, (x1,y2)=(${x1},${y1}) vs (x2,y2)=(${x2},${text2_length-y2})`);
                            return [x1, y1];
                        }
                    }
                }
            }
        }
        // No overlap; completely different strings, no common substring.
        return null;
    }
    /**
     * Breaks a string into individual characters, and returns an array view of those characters.
     */
    static fromCharacters(str) {
        return new ArrayView(str.split(''));
    }
    /**
     * Breaks a string into tokens based on any regular expression, and returns an array view of those tokens.
     */
    static fromTokens(str, re) {
        const tokens = [];
        if (str) { // odd case of empty string
            const str_length = str.length;
            let m;
            let last_non_token_idx = 0;
            while ((m = re.exec(str)) !== null) {
                // console.log(`Found ${m[0]} at ${m.index}. Next starts at ${re.lastIndex}.`);
                const m_index = m.index;
                while (m_index > last_non_token_idx) { // add all non-token characters as their own token
                    tokens[tokens.length] = str.substring(last_non_token_idx, last_non_token_idx + 1);
                    ++last_non_token_idx;
                }
                tokens[tokens.length] = str.substring(last_non_token_idx, re.lastIndex); // add this entire token
                last_non_token_idx = re.lastIndex; // remember where we are
            }
            while (last_non_token_idx < str_length) { // drain any remaining non-tokens
                tokens[tokens.length] = str.substring(last_non_token_idx, last_non_token_idx + 1);
                ++last_non_token_idx;
            }
        }
        return new ArrayView(tokens);
    }
    /**
     * Tokenizes a string assuming the use-case is plain-text prose.
     */
    static fromPlainProse(str) {
        return ArrayView.fromTokens(str, /\w+/g); // inline constant regex is faster than loading from a private static class variable
    }
    /**
     * Tokenizes a string by lines.  Includes the line-ending character as well.
     */
    static fromLines(str) {
        if (!str)
            return ArrayView.createEmpty(); // special case
        return new ArrayView(str.split(/([^\r\n]*(?:\r?\n|$))/g).filter(str => str.length > 0)); // FIXME: Slower, but Safari dies when we try the better one below
        // return new ArrayView( str.split(/(?<=\r?\n)/g) );     // splitting with non-consuming pattern (is this slow? is there a better way?)
    }
}
exports.ArrayView = ArrayView;
/**
 * Generates a histogram from a set of tokens, counting the number of times each appears, and the location
 * that the first instance of that token appears.
 */
class Histogram {
    constructor(input) {
        /**
         * Map of each unique symbol's ID to its information record.
         */
        this.histogram = {};
        /**
         * Map of the relative-position in the original input, to the symbol ID, and a field that can be used in algorithms to
         */
        this.ordered = [];
        const hist = this.histogram;
        const a = input.a;
        const a_start = input.start;
        const len = input.length;
        for (let k = 0; k < len; ++k) {
            const id = this.getIdForElement(a[a_start + k]);
            let r = hist[id];
            if (!r) { // if the first time, create the record
                r = {
                    id: id,
                    count: 1,
                    first_offset: k,
                };
                hist[id] = r;
            }
            else { // not the first time, increment the count
                ++r.count;
            }
            this.ordered.push({
                id: id,
            });
        }
    }
    /**
     * Given an element from the original input, returns its histogram record, or `undefined` if it's not present in the original input
     */
    lookupElement(el) {
        return this.histogram[this.getIdForElement(el)];
    }
    /**
     * Converts any type of element into a unique ID that is used as a key in the histogram array.
     */
    getIdForElement(el) {
        if (typeof el == "string" || typeof el == "number") {
            return el;
        }
        return JSON.stringify(el); // FIXME: need a different algorithm that orders keys and such; should be in another project
    }
}
exports.Histogram = Histogram;
// Describes a step in transforming "prev" to "next."
class Edit {
    constructor(prev, next) {
        this.prev = prev;
        this.next = next;
        // nothing to do except set the fields
    }
    static createEquality(keep) {
        return new Edit(keep, keep); // must be the same object, not just duplicate data, for fast-check of equality later
    }
    static createPureInsertion(ins) {
        return new Edit(ArrayView.createEmpty(), ins); // must be the same object, not just duplicate data, for fast-check of equality later
    }
    static createPureDeletion(del) {
        return new Edit(del, ArrayView.createEmpty()); // must be the same object, not just duplicate data, for fast-check of equality later
    }
    /**
     * True if this edit represents equal subsequences in the previous and next.
     *
     * @readonly
     */
    isEquality() {
        return this.prev.equals(this.next);
    }
    /**
     * True if this edit is an insertion, with no deletion.
     *
     * @readonly
     */
    isPureInsertion() {
        return this.prev.empty && !this.next.empty;
    }
    /**
     * True if this edit is a deletion, with no insertion.
     *
     * @readonly
     */
    isPureDeletion() {
        return !this.prev.empty && this.next.empty;
    }
    /**
     * True if this edit is a modification, i.e. both a non-trivial delete and a non-trivial insert at the same location.
     *
     * @readonly
     */
    isModification() {
        return !this.next.empty && !this.prev.empty && !this.isEquality();
    }
    /**
     * Creates and returns a new Edit object, that is the same as this one, but the opposite.
     * Inserts become deletes. Equalities are returned without creating a new Edit object.
     *
     * @readonly
     */
    getConverse() {
        return this.isEquality() ? this : new Edit(this.next, this.prev);
    }
    /**
     * Returns a human-readable, but not machine-usable, representation of this edit
     *
     * @param matched {boolean} if true, "equality" operations are surrounded by parenthesis to be explicit, otherwise they are plain for easier readability
     */
    toString(matched = false) {
        if (this.isEquality()) {
            return matched ? `(${this.prev.toString()})` : this.prev.toString();
        }
        if (this.isPureDeletion()) {
            return `[${this.prev.toString()}]`;
        }
        if (this.isPureInsertion()) {
            return `{${this.next.toString()}}`;
        }
        return `[${this.prev.toString()}]{${this.next.toString()}}`;
    }
}
exports.Edit = Edit;
// A list of edits, with various algorithms for that list.
class EditScript {
    constructor() {
        this.edits = [];
        // nothing more to do
    }
    get length() {
        return this.edits.length;
    }
    get empty() {
        return this.edits.length == 0;
    }
    append(e) {
        this.edits.push(e);
        return this;
    }
    prepend(e) {
        this.edits.unshift(e);
        return this;
    }
    /**
     * Returns a human-readable, but not machine-usable, representation of the entire edit script.
     *
     * @param matched {boolean} if true, "equality" operations are surrounded by parenthesis to be explicit, otherwise they are plain for easier readability
     */
    toString(matched = false) {
        return this.edits.map((e) => e.toString(matched)).join('');
    }
    /**
     * Given the output of `EditScript<T>.toString()`, parses and returns the result as a string-typed EditScript.
     */
    static fromString(s) {
        var _a, _b, _c, _d, _e, _f;
        const result = new EditScript();
        let m;
        // Find all deletions
        let deletions = [];
        while ((m = EditScript.re_delete.exec(s)) !== null) {
            deletions.push({
                edit: new Edit(ArrayView.fromCharacters(m[1]), ArrayView.createEmpty()),
                offset: m.index,
            });
        }
        // Find all insertions
        let insertions = [];
        while ((m = EditScript.re_insert.exec(s)) !== null) {
            insertions.push({
                edit: new Edit(ArrayView.createEmpty(), ArrayView.fromCharacters(m[1])),
                offset: m.index,
            });
        }
        // Find all equalities
        let equals = [];
        while ((m = EditScript.re_equal.exec(s)) !== null) {
            const av = ArrayView.fromCharacters(m[1]);
            equals.push({
                edit: new Edit(av, av),
                offset: m.index,
            });
        }
        // Splice it all together
        let di = 0;
        let ii = 0;
        let ei = 0;
        while (di < deletions.length || ii < insertions.length || ei < equals.length) {
            const d_offset = (_b = (_a = deletions[di]) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : Number.MAX_SAFE_INTEGER;
            const i_offset = (_d = (_c = insertions[ii]) === null || _c === void 0 ? void 0 : _c.offset) !== null && _d !== void 0 ? _d : Number.MAX_SAFE_INTEGER;
            const e_offset = (_f = (_e = equals[ei]) === null || _e === void 0 ? void 0 : _e.offset) !== null && _f !== void 0 ? _f : Number.MAX_SAFE_INTEGER;
            if (e_offset < d_offset && e_offset < i_offset) {
                result.append(equals[ei++].edit);
            }
            else if (d_offset < e_offset && d_offset < i_offset) {
                result.append(deletions[di++].edit);
            }
            else if (i_offset < e_offset && i_offset < e_offset) {
                result.append(insertions[ii++].edit);
            }
            else {
                throw new Error("Shouldn't get here.");
            }
        }
        // Join insert/delete pairs into a single modification
        result.visitEditPairs((left, right) => {
            if (left.isPureDeletion() && right.isPureInsertion()) {
                return [new Edit(left.prev, right.next)];
            }
            return null;
        });
        return result;
    }
    /**
     * Recreate the "previous" sequence using only edits, concatenating back to an array.
     */
    getPrev() {
        const result = [];
        for (let k = 0; k < this.edits.length; ++k) {
            this.edits[k].prev.pushAll(result);
        }
        return result;
    }
    /**
     * Recreate the "next" sequence using only edits, concatenating back to an array.
     */
    getNext() {
        const result = [];
        for (let k = 0; k < this.edits.length; ++k) {
            this.edits[k].next.pushAll(result);
        }
        return result;
    }
    /**
     * Creates and returns a new EditScript, that is the same as this one, but goes the opposite direction.
     * Inserts become deletes.
     */
    getConverse() {
        const converse = new EditScript();
        this.edits.forEach((ed) => { converse.edits[converse.length] = ed.getConverse(); });
        return converse;
    }
    /**
     * Creates a string, assuming the script represents strings of text, emitting lines with a gutter
     * of '+' for insertion, '-' for deletion, or ' ' for equality.
     */
    getScriptAsFormattedLines() {
        const result = [];
        const appendLines = (av, prefix) => {
            result[result.length] = av.mapToString((el) => prefix + el).join('');
        };
        this.visitEditsForward((ed) => {
            if (ed.isEquality()) {
                appendLines(ed.prev, ' ');
            }
            else {
                appendLines(ed.prev, '-');
                appendLines(ed.next, '+');
            }
        });
        return result.join('');
    }
    /**
     * Visits all Edits, in forward order (which disallows changing the edit list while iterating).
     */
    visitEditsForward(f_visit) {
        const edits = this.edits; // speedup
        const len = edits.length;
        for (let ei = 0; ei < len; ++ei) {
            f_visit(edits[ei]);
        }
    }
    /**
     * Visits all Edits, in reverse order (which allows for changes to the underlying edit script).
     *
     * The callback function can return null to indicate that no change should be made in the edit script,
     * or it can return an array which replaces the two edits completely.  If some of the edits should be
     * preserved, just include them in the array.  It is legal for the array to be any length, including empty.
     */
    visitEdits(f_visit) {
        const edits = this.edits; // speedup
        for (let ei = edits.length; --ei >= 0;) {
            const replacement = f_visit(edits[ei]);
            if (replacement !== null) {
                this.edits.splice(ei, 1, ...replacement);
            }
        }
    }
    /**
     * Visits all pairs of Edits, in reverse order (which allows for changes to the underlying edit script).
     * Won't visit anything if there's just one Edit.
     *
     * The callback function can return null to indicate that no change should be made in the edit script,
     * or it can return an array which replaces the two edits completely.  If some of the edits should be
     * preserved, just include them in the array.  It is legal for the array to be any length, including empty.
     */
    visitEditPairs(f_visit) {
        const edits = this.edits; // speedup
        for (let ei = edits.length - 1; --ei >= 0;) {
            const replacement = f_visit(edits[ei], edits[ei + 1]);
            if (replacement !== null) {
                this.edits.splice(ei, 2, ...replacement);
            }
        }
    }
    /**
     * Visits all trios of Edits, in reverse order (which allows for changes to the underlying edit script).
     * Won't visit anything if there are fewer than three Edits.
     *
     * The callback function can return null to indicate that no change should be made in the edit script,
     * or it can return an array which replaces the three edits completely.  If some of the edits should be
     * preserved, just include them in the array.  It is legal for the array to be any length, including empty.
     */
    visitEditTrios(f_visit) {
        const edits = this.edits; // speedup
        for (let ei = edits.length - 1; --ei > 0;) {
            const replacement = f_visit(edits[ei - 1], edits[ei], edits[ei + 1]);
            if (replacement !== null) {
                this.edits.splice(ei - 1, 3, ...replacement);
            }
        }
    }
    /**
     * Scans for an Equality edit (the "middle"), surrounded on both sides by either two insertions, two deletions,
     * or one modification and any change on the other side. These are the conditions in which it is
     * legal to join the left, middle, and right edits into a single edit. While the resulting script is
     * identical, it reduces the total number of edits in a way that might be preferable, usually for semantic
     * reasons.  For example, a single space separating changes to words on either side, probably should be
     * folded into a single semantically-meaningful change.
     *
     * A callback function is consulted to determine whether this transformation should actually be executed.
     * The callback is provided the Middle content, and is called only if the surrounding Edits are valid for
     * this transformation.
     */
    collapseMiddleEquality(f_should_collapse) {
        this.visitEditTrios((left, middle, right) => {
            if (middle.isEquality() && (left.isModification() || right.isModification() || left.isPureDeletion() == right.isPureDeletion())) {
                if (f_should_collapse(middle.prev)) {
                    return [
                        new Edit(new ArrayView(left.prev.a, left.prev.start, right.prev.end), new ArrayView(right.next.a, left.next.start, right.next.end))
                    ];
                }
            }
            return null;
        });
    }
    /**
     * Attempts to further simplify all non-pure modifications, changing the script in-place.
     * Returns true if any were transformed, otherwise returns false.
     *
     * Supply a preconfigured engine to execute simplifications.
     */
    reeditModifications(simplification_engine) {
        let made_change = false;
        this.visitEdits((e) => {
            if (!e.isModification()) { // only interested in non-pure modifications
                return null;
            }
            const new_edits = simplification_engine.getEdits(e.prev, e.next); // attempt a simple simplification
            if (new_edits.length > 1) {
                made_change = true;
                return new_edits.edits;
            }
            return null;
        });
        return made_change;
    }
    /**
     * Reduces edits until they alternate between equality and modification.
     * Returns true if there was at least one coalesing of a modification-style edit.
     */
    coalesce() {
        let coalesced_modification = false;
        this.visitEditPairs((left, right) => {
            if (left.isEquality() !== right.isEquality()) { // alternating equal / modification is what we want
                return null;
            }
            const edit = new Edit(// replace the two with a single one that spans both
            left.prev.concat(right.prev), left.next.concat(right.next));
            if (!edit.isEquality()) {
                coalesced_modification = true;
            }
            return [edit];
        });
        return coalesced_modification;
    }
    /**
     * Rewrites Edit records to shift rightward when it is possible to do so without changing the result.
     * This is a way to normalize output, as well as often semantically better, as it makes insertions closer
     * to an append.  For example, with "Hello." vs "Hello...", you could report "Hello{..}." but "Hello.{..}"
     * is more likely to be what is intended.
     *
     * It is possible that an equality is completely eliminated as a result of this.  If that happens, this will
     * automatically run a coalese() to restore the system to its normal state.
     *
     * This will also shift edits leftward in the special case that doing so would cause one "equality" Edit to
     * completely disappear, thus collecting into fewer total edits.  In all other cases, shifting is rightward-only.
     *
     * Returns `true` if any changes were made, `false` otherwise.
     */
    shiftEdits() {
        let made_change = false;
        let needs_coalesce = false;
        // Shift pure changes rightward.  See unit tests for examples that make this clearer.
        this.visitEditTrios((left, middle, right) => {
            if (left.isEquality() && right.isEquality()) {
                const middle_is_pure_insert = middle.isPureInsertion();
                const middle_is_pure_delete = middle.isPureDeletion();
                if (middle_is_pure_insert || middle_is_pure_delete) { // modifications do not shift; see unit tests for why
                    let new_left = middle_is_pure_insert ? left.next : left.prev;
                    let new_middle = middle_is_pure_insert ? middle.next : middle.prev;
                    let new_right = middle_is_pure_insert ? right.next : right.prev;
                    let len = new_middle.getLengthOfCommonPrefix(new_right);
                    if (len > 0) {
                        // Build up the new strings, but in a way that we can repeat the process to shift even further in certain cases (see unit tests)
                        made_change = true;
                        while (len > 0) {
                            const prefix = new_middle.getSubsequence(0, len);
                            new_left = new_left.concat(prefix);
                            new_middle = new_middle.getSubsequence(len).concat(prefix);
                            new_right = new_right.getSubsequence(len);
                            len = new_middle.getLengthOfCommonPrefix(new_right); // try again!
                        }
                        // Return new edits with the final values of the arrays
                        const result = [
                            Edit.createEquality(new_left),
                            middle_is_pure_insert ? Edit.createPureInsertion(new_middle) : Edit.createPureDeletion(new_middle),
                        ];
                        if (new_right.length > 0) { // it's possible that the equality is completely consumed
                            result.push(Edit.createEquality(new_right));
                        }
                        else {
                            needs_coalesce = true; // eliminating an equality means we need to restore our invariant later
                        }
                        return result;
                    }
                }
            }
            return null;
        });
        // Fix edits, if we screwed up the invariant above by eliminating an equality.
        if (needs_coalesce) {
            this.coalesce();
            // Do we need to run ourselves again?  Isn't it possible that now there are new opportunites?
            // So far, haven't come up with a unit test to demonstrate this.  So it's OK to leave it for now.
        }
        // Shift pure changes leftward, but only in the special case that shifting left will completely eliminate an equality.
        // Normally everything should move to the right, but if we can collect equalities and changes smarter, that's worth it.
        needs_coalesce = false;
        this.visitEditPairs((left, right) => {
            if (left.isEquality() && (right.isPureInsertion() || right.isPureDeletion())) {
                const target = right.isPureInsertion() ? right.next : right.prev;
                if (left.prev.equals(target)) { // exactly eliminates equality?
                    made_change = true;
                    needs_coalesce = true; // because we're screwing with the parity, the invariant is broken and we have to fix it
                    return [right, left]; // swap them
                }
            }
            return null;
        });
        if (needs_coalesce) {
            this.coalesce();
        }
        return made_change;
    }
}
exports.EditScript = EditScript;
EditScript.re_delete = /\[([^\]]*)\]/g;
EditScript.re_insert = /\{([^\}]*)\}/g;
EditScript.re_equal = /(?:^|[\}\]])([^\{\[]+)/g;
class MergeOp {
    constructor(common_start, common_end, insert) {
        this.common_start = common_start;
        this.common_end = common_end;
        this.insert = insert;
        // nothing to do
    }
    toString() {
        return `common=[${this.common_start},${this.common_end}) + "${this.insert.toString()}"`;
    }
}
;
var MergeConflictingInsertsAlgorithm;
(function (MergeConflictingInsertsAlgorithm) {
    MergeConflictingInsertsAlgorithm[MergeConflictingInsertsAlgorithm["KEEP_STATUS_QUO"] = 0] = "KEEP_STATUS_QUO";
    MergeConflictingInsertsAlgorithm[MergeConflictingInsertsAlgorithm["KEEP_BOTH"] = 1] = "KEEP_BOTH";
    MergeConflictingInsertsAlgorithm[MergeConflictingInsertsAlgorithm["MERGE"] = 2] = "MERGE";
})(MergeConflictingInsertsAlgorithm = exports.MergeConflictingInsertsAlgorithm || (exports.MergeConflictingInsertsAlgorithm = {}));
;
/**
 * An engine that can perform two-way or three-way merge, with configuration settings.
 */
class Merge {
    constructor() {
        /**
         * If true, examine inserts that happen at exactly the same place, combining common prefix, suffix, or when a prefix
         * of one matches a suffix of the other.
         *
         * When diffs might have already been applied, or in the case where the alphabet contains unique items, this will merge
         * better.  Otherwise it can incorrectly merge things that are truly separate, for example if both sides append a new
         * bullet point to a section, this setting will incorrectly "merge" the two bullet points, when in fact they are logically
         * completely separate the minds of the authors.  On the other hand, if one person pasted part of a change that another
         * person made, this option will resolve that properly, instead of actually having two copies of the pasted part.
         *
         * Default: False.
         */
        this.opt_combine_overlapping_inserts = MergeConflictingInsertsAlgorithm.KEEP_BOTH;
        /**
         * If we are combining overlapping inserts (see other options), this is the algorithm used to merge.
         */
        this.opt_algorithm_combined_overlapping_inserts = DiffAlgorithm.SIMPLE;
        this.take_both_diff_engine = null; // created lazily when/if needed
        // The default way to handle deleted inserts is to do nothing
        this.opt_f_handle_deleted_insert = () => { };
    }
    /**
     * Given two arrays, which are theoretically "matched up" (e.g. two insertions at the same location), create a
     * new array that "merges" both, meaning taking content from both, but including duplicated content only once.
     * There is no such thing as a "deletion."  All change are assumed to be content that needs to be kept.
     *
     * For example, ("a","b") => "ab", but ("hi there","hi you") => "hi thereyou".
     */
    takeBoth(a, b, algorithm) {
        // Trivial cases
        if (a.empty)
            return b.getCopy();
        if (b.empty)
            return a.getCopy();
        if (a.equals(b))
            return a.getCopy();
        // Generate diffs; this combines equal zones, which prevents us from duplicating those zones.
        let eng = this.take_both_diff_engine;
        if (!eng) {
            this.take_both_diff_engine = eng = new Engine();
            eng.opt_shift_rightward = false; // no need -- this won't change the output!
        }
        eng.opt_algorithm = algorithm;
        const edits = eng.getEdits(a, b);
        // Use the edits to take all unique strings.
        const result = [];
        edits.visitEditsForward((edit) => {
            edit.prev.pushAll(result); // Always emit the "previous"
            if (!edit.isEquality()) {
                edit.next.pushAll(result);
            }
        });
        return result;
    }
    /**
     * Three-way merge between a common state and the "status quo" (which is the default "winner," when we need a tie-breaker), and
     * a set of differences between the same common state and a state to "apply."
     *
     * Most situations are symmetrical, but not all, hence the difference in semantics.
     *
     * If the common state is available, it can be passed in.  Otherwise, it is computed from the differences.
     */
    merge3(status_quo, apply, common = null) {
        var _a, _b, _c, _d, _e, _f;
        // Ensure we have the common array
        if (common === null) {
            common = status_quo.getPrev();
        }
        // console.log(`MERGE: [${common.join('')}] <- [${status_quo.toString(true)}] <- [${apply.toString(true)}]`);
        const common_length = common.length;
        // Preprocess. We want indexes into the common string, so we can leap to changes.
        // We want intervals of deletion, so we can expand overlaps.
        // We want locations of insertion, so we can insert after the fact.
        function createOpsFromEdits(script) {
            const ops = [];
            let common_i = 0;
            script.visitEditsForward((edit) => {
                const common_end = common_i + edit.prev.length;
                if (!edit.isEquality()) { // only modifications are operations that we care about
                    ops.push(new MergeOp(common_i, common_end, edit.next));
                }
                common_i = common_end;
            });
            return ops;
        }
        const quo_ops = createOpsFromEdits(status_quo);
        const app_ops = createOpsFromEdits(apply);
        const quo_ops_length = quo_ops.length;
        const app_ops_length = app_ops.length;
        // console.log("    QUO:", quo_ops.join('; '));
        // console.log("    APP:", app_ops.join('; '));
        // Walk both sides at the same time, processing whichever one comes sooner, or possibly at the same time.
        let common_i = 0; // currently looking at this point in the common
        let quo_i = 0;
        let app_i = 0;
        const result = [];
        while (common_i < common_length || quo_i < quo_ops_length || app_i < app_ops_length) {
            const quo_op_start = (_b = (_a = quo_ops[quo_i]) === null || _a === void 0 ? void 0 : _a.common_start) !== null && _b !== void 0 ? _b : common_length;
            const app_op_start = (_d = (_c = app_ops[app_i]) === null || _c === void 0 ? void 0 : _c.common_start) !== null && _d !== void 0 ? _d : common_length;
            // While we haven't hit the next operation, emit a common element.
            while (common_i < quo_op_start && common_i < app_op_start) {
                result.push(common[common_i++]);
            }
            // Determine the next operation.  The answer can be "both" if the operations are located at the same spot.
            let op1;
            let op2;
            if (quo_op_start <= app_op_start) {
                op1 = quo_ops[quo_i++];
            }
            if (app_op_start <= quo_op_start) {
                op2 = app_ops[app_i++];
            }
            if (!op1 && !op2) { // all done?
                break; // we're done with common too, because of the previous while loop
            }
            // If both operations have insertions (whether or not pure), then we have some special things to do.
            if (op1 && op2 && !op1.insert.empty && !op2.insert.empty) {
                // If our double-insert mode is to just keep status quo, do that.
                if (this.opt_combine_overlapping_inserts === MergeConflictingInsertsAlgorithm.KEEP_STATUS_QUO) {
                    op1.insert.pushAll(result);
                }
                else {
                    // Always sort first for a stable result regardless of order of merge.
                    // If the items are identical, always emit just one of them; never just duplicate, and no further calculation is needed.
                    // If they're not identical, but we're supposed to run a merge algorithm, do that.
                    // If none of the above, we're supposed to keep both, so just do that.
                    const cmp = op1.insert.compare(op2.insert);
                    if (cmp > 0) { // ensure well-ordered
                        [op1, op2] = [op2, op1];
                    }
                    if (cmp === 0) {
                        op1.insert.pushAll(result);
                    }
                    else if (this.opt_combine_overlapping_inserts === MergeConflictingInsertsAlgorithm.MERGE) { // unequal, and we're supposed to be an algorithm
                        result.push(...this.takeBoth(op1.insert, op2.insert, this.opt_algorithm_combined_overlapping_inserts));
                    }
                    else {
                        op1.insert.pushAll(result);
                        op2.insert.pushAll(result);
                    }
                }
            }
            // Apply insertions, if any.
            else {
                if (op1) {
                    op1.insert.pushAll(result);
                }
                if (op2) {
                    op2.insert.pushAll(result);
                }
            }
            // Apply deletion.  Any operations from either list, which are contained in the deletion zone, are skipped,
            // but not before _their_ deletion area is added to the list.  Keep going on both lists until exhaustion.
            let common_next = imax(op1 ? op1.common_end : common_i, op2 ? op2.common_end : common_i);
            let more = true;
            while (more) {
                more = false;
                if (((_e = quo_ops[quo_i]) === null || _e === void 0 ? void 0 : _e.common_start) < common_next) {
                    const op = quo_ops[quo_i++];
                    common_next = imax(common_next, op.common_end);
                    if (!op.insert.empty) {
                        this.opt_f_handle_deleted_insert(result, op.insert);
                    }
                    more = true;
                }
                if (((_f = app_ops[app_i]) === null || _f === void 0 ? void 0 : _f.common_start) < common_next) {
                    const op = app_ops[app_i++];
                    common_next = imax(common_next, op.common_end);
                    if (!op.insert.empty) {
                        this.opt_f_handle_deleted_insert(result, op.insert);
                    }
                    more = true;
                }
            }
            common_i = common_next; // skip the deletion area in the common string
        }
        // Done
        return result;
    }
}
exports.Merge = Merge;
// Intentionally not module-exported; instead it is exported via a static class member, for scoping.
var DiffAlgorithm;
(function (DiffAlgorithm) {
    DiffAlgorithm[DiffAlgorithm["PREPROCESSOR_ONLY"] = 0] = "PREPROCESSOR_ONLY";
    DiffAlgorithm[DiffAlgorithm["SIMPLE"] = 1] = "SIMPLE";
    DiffAlgorithm[DiffAlgorithm["LCS"] = 2] = "LCS";
    DiffAlgorithm[DiffAlgorithm["MYERS"] = 3] = "MYERS";
    DiffAlgorithm[DiffAlgorithm["HECKEL"] = 4] = "HECKEL";
    DiffAlgorithm[DiffAlgorithm["PATIENCE"] = 5] = "PATIENCE";
})(DiffAlgorithm = exports.DiffAlgorithm || (exports.DiffAlgorithm = {}));
// A diff-engine that has options and can compute differences between sequences.
class Engine {
    constructor() {
        // Option: The algorithm to use for differencing.  The preprocessor always runs first regardless.
        this.opt_algorithm = DiffAlgorithm.LCS;
        // Option: If specified, after the differences are computed, this algorithm is executed on all non-pure modifications.
        this.opt_secondary_algorithm = null;
        // Option: Shift edits rightward where possible, often generating more semantically-sensible differences.
        // This is not used in the pre-processor, only with "real" algorithms.
        this.opt_shift_rightward = true;
        // Option: If not null, a callback function that determines whether to collapse certain equality edits, as
        // defined by `EditScript.collapseMiddleEquality()`.
        this.opt_f_collapse_equalities = null;
        // Option: What algorithm to use for computing the Longest Common Substring between two sequences.
        // Default is the Optmistic Bisection method.  Other methods return the same results, just with possibly different
        // performance characteristics, therefore there's usually no reason to change it.
        this.opt_f_lcs = ArrayView.getLongestCommonSubstringOptimisticBisect;
        // nothing for now
    }
    /**
     * Computes and returns the edit sequence that transforms `prev` into `next`, according to the configured options.
     */
    getEdits(prev, next) {
        // console.log("getEdits", `[${prev.toString()}] -> [${next.toString()}]`);
        var _a;
        // "Patience" algorithm is really recursive Heckel, so convert that now.
        if (this.opt_algorithm == DiffAlgorithm.PATIENCE) {
            this.opt_algorithm = DiffAlgorithm.HECKEL;
            this.opt_secondary_algorithm = DiffAlgorithm.HECKEL;
        }
        // Determine the processor based on the engine's options
        let inner_processor;
        switch (this.opt_algorithm) {
            case DiffAlgorithm.PREPROCESSOR_ONLY:
                inner_processor = this.executeSingleModification;
                break;
            case DiffAlgorithm.SIMPLE:
                inner_processor = (edits, depth, prev, next) => {
                    this.executeSimple(edits, depth, prev, next, this.executeSingleModification);
                };
                break;
            case DiffAlgorithm.LCS:
                inner_processor = (edits, depth, prev, next) => {
                    this.executeLongestCommonSubstring(edits, depth, prev, next);
                };
                break;
            case DiffAlgorithm.MYERS:
                inner_processor = (edits, depth, prev, next) => {
                    this.executeMyers(edits, depth, prev, next);
                };
                break;
            case DiffAlgorithm.HECKEL:
                inner_processor = (edits, depth, prev, next) => {
                    this.executeHeckel(edits, depth, prev, next);
                };
                break;
            default:
                throw new Error(`Unknown diff algorithm: ${this.opt_algorithm}`);
        }
        // Execute!
        const edits = new EditScript();
        this.executePreprocessor(edits, 0, prev, next, inner_processor);
        // Some diff algorithms need a clean-up pass on the edits, removing trivial ones, combining consecutive modifications.
        // After that, simplify the modifications we just created; it's easy to have repeating substrings now.
        if (this.opt_algorithm == DiffAlgorithm.MYERS || this.opt_algorithm == DiffAlgorithm.HECKEL) {
            // console.log("COALESCE:       before: ", edits.toString(true));
            edits.coalesce();
            // console.log("COALESCE: after pass 1: ", edits.toString(true));
            const simplification_engine = new Engine();
            simplification_engine.opt_algorithm = (_a = this.opt_secondary_algorithm) !== null && _a !== void 0 ? _a : DiffAlgorithm.PREPROCESSOR_ONLY;
            const made_change = edits.reeditModifications(simplification_engine);
            // console.log("COALESCE: after pass 2: ", edits.toString(true), ` (changed? ${made_change})`);
            if (made_change) { // re-simplify, since we exploded into equalities that might be combined with surrounding equalities
                edits.coalesce();
                // console.log("COALESCE: after pass 3: ", edits.toString(true));
            }
        }
        // Shift edits rightward
        if (this.opt_shift_rightward) {
            edits.shiftEdits();
        }
        // If we need to collapse equalities, run that now that all the edits are known.
        if (this.opt_f_collapse_equalities) {
            edits.collapseMiddleEquality(this.opt_f_collapse_equalities);
        }
        // Done
        return edits;
    }
    /**
     * Computes the edit sequence that transforms `prev` into `next`, using a few fast operations, taking O(1), O(min(n,M)), or O(N) speed
     * and O(1) space. In simple cases, the entire edit sequence is determined; in complex cases, the simpler aspects are removed, leaving only
     * a challenge.
     *
     * The processor is called only if there is a remaining non-trivial difference. The arguments will be non-empty, and they will mis-match
     * at both their start and end, and they will be at least 2 elements in length; it can be useful for the subsequence processor to make use
     * of these facts to simply its algorithm.
     */
    executePreprocessor(edits, depth, prev, next, processor) {
        const prev_length = prev.length;
        const next_length = next.length;
        // console.log(`${"  ".repeat(depth)}PREPROCESSOR: [${prev}] -> [${next}]`);
        // Special case: Already one side is empty.  Possible both are, in which case it's also a no-op.
        if (prev_length <= 0) {
            if (next_length <= 0) {
                return; // no edits!
            }
            edits.append(new Edit(prev, next)); // just insert
            return;
        }
        else if (next_length <= 0) {
            edits.append(new Edit(prev, next)); // just delete
            return;
        }
        // Compute the common prefix and suffix lengths
        // Special case: If identical, exit early with a trivial edit script.
        let prefix_length = prev.getLengthOfCommonPrefix(next);
        if (prefix_length == prev_length && prefix_length === next_length) { // totally equal?
            if (prefix_length) { // anything to keep?  if not, it's two empty arrays, and truly no edits.
                edits.append(Edit.createEquality(prev));
            }
            return;
        }
        const suffix_length = prev.getLengthOfCommonSuffix(next);
        // Special case: When the same sequence appears on either side of a middle change, the prefix and suffix
        // can go past each other.  Can reduce either the prefix or the suffix; either produces valid diffs.
        // Semantically, with prose, it feels better to reduce prefix. If you replace the changes
        // in `prefix_length` below with `suffix_length`, certain unit tests fail, which demonstrate the semantic choice.
        const prev_overage = prefix_length + suffix_length - prev_length;
        if (prev_overage > 0) {
            prefix_length -= prev_overage;
        }
        const next_overage = prefix_length + suffix_length - next_length;
        if (next_overage > 0) {
            prefix_length -= next_overage;
        }
        // Create the prev/next of the remaining middle (which might be empty in one case, but not both; equality is already handled)
        const prev_middle = prev.getSubsequence(prefix_length, prev_length - suffix_length - prefix_length);
        const next_middle = next.getSubsequence(prefix_length, next_length - suffix_length - prefix_length);
        // Emit the prefix, process the middle, and emit the suffix.
        if (prefix_length) {
            edits.append(Edit.createEquality(prev.getSubsequence(0, prefix_length)));
        }
        this.executeEasyCases(edits, depth + 1, prev_middle, next_middle, processor); // wrap the middle in a processor of more "easy" cases
        if (suffix_length) {
            edits.append(Edit.createEquality(prev.getSubsequence(prev_length - suffix_length, suffix_length)));
        }
    }
    /**
     * A trivial execution processor, that just emits a single "modification" edit, sending `prev` to `next`.
     */
    executeSingleModification(edits, depth, prev, next) {
        edits.append(new Edit(prev, next));
    }
    /**
     * Attempts to completely evaluate the differences using only simple and fast algorithms, i.e. when worse-case is
     * O(1) or O(N).  If those cases are handled, the subprocessor will not be invoked; otherwise it will be invoked
     * as the simpler cases were unsuccessful.
     */
    executeEasyCases(edits, depth, prev, next, processor) {
        const prev_length = prev.length;
        const next_length = next.length;
        // console.log(`EASY: "${prev.toString()}" -> "${next.toString()}"`);
        // Special case: One is completely empty, in which case it's a pure insert or delete
        if (prev_length === 0) {
            edits.append(Edit.createPureInsertion(next));
            return;
        }
        if (next_length === 0) {
            edits.append(Edit.createPureDeletion(prev));
            return;
        }
        // Special case: Both are of length 1. Since they're unequal, the only thing to do is enqueue a modification.
        // Special case: One is of length 1, the other of length 2. But no prefix/suffix means the two are both unequal to the one.
        if ((prev_length <= 1 && next_length <= 2) || (next_length <= 1 && prev_length <= 2)) {
            if (prev_length > 0 || next_length > 0) { // can be that both are empty, in which case we shouldn't emit anything
                edits.append(new Edit(prev, next));
            }
            return;
        }
        // No simple case; proceed to the next algorithm.
        processor(edits, depth, prev, next);
    }
    /**
     * Identifies a few straightforward cases, such as when there's an overlap at the start or end, or when the smaller is a
     * subset of the longer.  If no straightforward case is successful, the given process is called to continue working on the
     * problem, otherwise it is not invoked.
     */
    executeSimple(edits, depth, prev, next, processor) {
        // console.log(`${"  ".repeat(depth)}SIMPLE: [${prev}] -> [${next}]`);
        const prev_length = prev.length;
        const next_length = next.length;
        let len;
        // Check for the smaller being a direct substring of the longer.
        if (prev_length <= next_length) {
            const p = next.indexOfSubstring(prev);
            if (p >= 0) {
                // console.log(`${"  ".repeat(depth)}SIMPLE: found prev inside next`);
                if (p > next.start) {
                    edits.append(Edit.createPureInsertion(new ArrayView(next.a, next.start, p - 1)));
                }
                edits.append(Edit.createEquality(prev));
                const q = p + prev.length;
                if (q <= next.end) {
                    edits.append(Edit.createPureInsertion(new ArrayView(next.a, q, next.end)));
                }
                return;
            }
        }
        else {
            const p = prev.indexOfSubstring(next);
            if (p >= 0) {
                // console.log(`${"  ".repeat(depth)}SIMPLE: found next inside prev`);
                if (p > prev.start) {
                    edits.append(Edit.createPureDeletion(new ArrayView(prev.a, prev.start, p - 1)));
                }
                edits.append(Edit.createEquality(next));
                const q = p + next.length;
                if (q <= prev.end) {
                    edits.append(Edit.createPureDeletion(new ArrayView(prev.a, q, prev.end)));
                }
                return;
            }
        }
        // Check whether the ending of one is equal to the start of the other.  If so, we'll take that commonality as an "equality."
        len = prev.getLengthOfOverlapAtMyEnd(next);
        if (len > 0) {
            // console.log(`${"  ".repeat(depth)}SIMPLE: found end of prev matches front of next, len=${len}`);
            edits.append(Edit.createPureDeletion(prev.getSubsequence(0, prev.length - len)));
            edits.append(Edit.createEquality(prev.getSubsequence(prev.length - len)));
            edits.append(Edit.createPureInsertion(next.getSubsequence(len)));
            return;
        }
        len = next.getLengthOfOverlapAtMyEnd(prev);
        if (len > 0) {
            // console.log(`${"  ".repeat(depth)}SIMPLE: found end of next matches front of prev, len=${len}`);
            edits.append(Edit.createPureInsertion(next.getSubsequence(0, next.length - len)));
            edits.append(Edit.createEquality(prev.getSubsequence(0, len)));
            edits.append(Edit.createPureDeletion(prev.getSubsequence(len)));
            return;
        }
        // No simple algorithm!
        processor(edits, depth, prev, next);
    }
    /**
     * Finds the longest common substring between two sides, keeping that as an "equality" edit, and recursively
     * computing the edit script for the two surrounding pieces.
     */
    executeLongestCommonSubstring(edits, depth, prev, next) {
        // Find the longest common substring, which we will retain as an equality.
        // If there's nothing at all, then it's just one big delete/insert.
        // If there is, recursively diff the sequences before and after the equality.
        const lcs = this.opt_f_lcs(prev, next);
        // console.log(`LCS of [${prev.toString()}],[${next.toString()}]: [${lcs[0].toString()}]`);
        if (lcs[0].empty) {
            edits.append(new Edit(prev, next));
        }
        else {
            this.executeLongestCommonSubstring(edits, depth + 1, new ArrayView(prev.a, prev.start, lcs[0].start - 1), new ArrayView(next.a, next.start, lcs[1].start - 1));
            edits.append(Edit.createEquality(lcs[0]));
            this.executeLongestCommonSubstring(edits, depth + 1, new ArrayView(prev.a, lcs[0].end + 1, prev.end), new ArrayView(next.a, lcs[1].end + 1, next.end));
        }
    }
    /**
     * Retains the longest common subsequence as equalities, producing minimal Edits for insert/delete.
     * This can miss the longest common substring, or "interesting" common elements, but does maximize
     * how much total material is kept.
     */
    executeMyers(edits, depth, prev, next) {
        // console.log(`${"  ".repeat(depth)}MYERS: [${prev}] -> [${next}]`);
        // Use the Myers method to find a point along the longest common subsequence path.
        // If there's nothing in common, edit a simple modification, otherwise recursively difference on either side of that point.
        // If we landed on a snake, we'll be at the head or tail, which will play nicely into the preprocessing steps.
        const midpoint = prev.getLongestCommonSubsequenceMiddleMyers(next);
        if (midpoint === null) {
            // console.log(`${"  ".repeat(depth)}>LCS midpoint: null`);
            edits.append(new Edit(prev, next));
        }
        else {
            console.log(`${"  ".repeat(depth)}>LCS midpoint: ${midpoint}: [${prev.getSubsequence(0, midpoint[0]).toString()}|${prev.getSubsequence(midpoint[0]).toString()}]/[${next.getSubsequence(0, midpoint[1]).toString()}|${next.getSubsequence(midpoint[1]).toString()}]`);
            this.executePreprocessor(edits, depth + 1, prev.getSubsequence(0, midpoint[0]), next.getSubsequence(0, midpoint[1]), this.executeMyers);
            this.executePreprocessor(edits, depth + 1, prev.getSubsequence(midpoint[0]), next.getSubsequence(midpoint[1]), this.executeMyers);
        }
    }
    /**
     * Runs a version of the algorithm of Heckel 1978, in which a histogram is used to locate the longest substring
     * that are not only common to both, but appear only once in both, then taking an equality there.
     *
     * This can create suboptimal modifications as it deals with "move" operations.  If you want to preserve the concept
     * of a move, then those aren't suboptimal!  If you don't, they can be coalesed into something simpler.
     */
    executeHeckel(edits, depth, old_file, new_file) {
        // console.log(`Heckel on [${old_file.toString()}],[${new_file.toString()}]`);
        var _a, _b, _c, _d, _e, _f;
        // Below, our language is of "reading lines from files," to match the language of Heckel's paper.  This makes it
        // more easy to follow along with the original paper, even though it's the wrong terminology for arbitrary-typed arrays.
        // Also we use symbols like "OA" and "NA" for variables, even though that's incorrect spelling for variables, again to
        // match the language of the original paper.
        // Pass 1 & 2. Read elements from both files, creating histograms of their unique tokens, with counts and references to their first "line number"
        // Here we don't need a separate OLNO record, because it's present in the histograms.
        const OA_hist = new Histogram(old_file);
        const NA_hist = new Histogram(new_file);
        const OA = OA_hist.ordered;
        const NA = NA_hist.ordered;
        const OA_length = OA.length;
        const NA_length = NA.length;
        const MAX_LINE = imax(OA_length, NA_length) + 1;
        // console.log("=== AFTER PASS 2 ============================="); console.log("OA:", OA); console.log("NA:", NA);
        // Pass 3.  Process only lines where the symbol appears exactly once in both files ("NC = OC = 1").
        // Rather than "replace the symbol with the line number," which is only to save bits in a 1976 world where that's important,
        // we update our histogram objects with that information, namely the line number in the other file where that symbol appears.
        for (let i = 0; i < NA_length; ++i) { // only need to scan one set of symbols, since it needs to appear in both places.
            const new_symbol = NA_hist.histogram[NA[i].id];
            if (new_symbol.count === 1) { // NC = 1?
                const old_symbol = OA_hist.histogram[new_symbol.id]; // lookup in old file
                if ((old_symbol === null || old_symbol === void 0 ? void 0 : old_symbol.count) === 1) { // present, and also OC = 1?
                    NA[i].other_offset = old_symbol.first_offset;
                    OA[old_symbol.first_offset].other_offset = new_symbol.first_offset;
                }
            }
        }
        // console.log("=== AFTER PASS 3 ============================="); console.log("OA:", OA); console.log("NA:", NA);
        // Pass 4.  Extend "equal lines" forward, seeded by the equalities we found in Pass 3.  Stop if we get to another set of equal lines.
        for (let i = 0; i < NA_length - 1; ++i) {
            const j = NA[i].other_offset;
            if (j !== undefined && j < OA_length - 1 && OA[j + 1].other_offset === undefined) { // "if NA[i] points to OA[j]"  (and I added: and j+1 is a valid thing to reference, and isn't already pointing back)
                if (NA[i + 1].id === OA[j + 1].id) { // "...and NA[i+1] and OA[j+1] contain identical symbol table entries"
                    OA[j + 1].other_offset = i + 1; // "then ... is set to ... and ..."
                    NA[i + 1].other_offset = j + 1;
                }
            }
        }
        // console.log("=== AFTER PASS 4 ============================="); console.log("OA:", OA); console.log("NA:", NA);
        // Pass 5:  Extend "equal lines" backward, seeded by the above, and stopping if we get to another set of equal lines.
        for (let i = NA_length; --i > 0;) {
            const j = NA[i].other_offset;
            if (j !== undefined && j > 0 && OA[j - 1].other_offset === undefined) {
                if (NA[i - 1].id === OA[j - 1].id) {
                    OA[j - 1].other_offset = i - 1;
                    NA[i - 1].other_offset = j - 1;
                }
            }
        }
        // console.log("=== AFTER PASS 5 ============================="); console.log("OA:", OA); console.log("NA:", NA);
        // "Array NA now contains the information needed to list the differences."
        // If NA has no "other," it is an insert.  If OA has no "other," it is a deletion.  If they have "others," it is an equality,
        // which can include moves in either direction.
        for (let i = 0, j = 0; i < NA_length || j < OA_length;) { // keep going until both are exhausted
            const i_start = i;
            const j_start = j;
            const new_other = (_a = NA[i]) === null || _a === void 0 ? void 0 : _a.other_offset; // if i == NA_length, this will be undefined
            const old_other = (_b = OA[j]) === null || _b === void 0 ? void 0 : _b.other_offset; // if j == OA_length, this will be undefined
            // If we have a block which is aligned to current indicies, emit as a natural equality.
            if (new_other === j && old_other === i) {
                while (i < NA_length && j < OA_length && NA[i].other_offset === j && OA[j].other_offset === i) {
                    ++i;
                    ++j;
                }
                const sequence = old_file.getSubsequence(j_start, j - j_start);
                // console.log(`equality: [${i_start},${i}), [${j_start},${j}) => "${sequence.toString()}"`);
                edits.append(Edit.createEquality(sequence));
                continue;
            }
            // If OLD is a block, but the NEW index is already past that point, it's a move-delete.
            if (old_other !== undefined && old_other < i) {
                while (j < OA_length && ((_c = OA[j].other_offset) !== null && _c !== void 0 ? _c : MAX_LINE) < i) {
                    ++j;
                }
                const sequence = old_file.getSubsequence(j_start, j - j_start);
                // console.log(`delete (move-backward): [${i_start},${i}), [${j_start},${j}) => "${sequence.toString()}"`);
                edits.append(Edit.createPureDeletion(sequence));
                continue;
            }
            // If NEW is a block, but the OLD index is already past that point, it's a move-insert.
            if (new_other !== undefined && new_other < j) {
                while (i < NA_length && ((_d = NA[i].other_offset) !== null && _d !== void 0 ? _d : MAX_LINE) < j) {
                    ++i;
                }
                const sequence = new_file.getSubsequence(i_start, i - i_start);
                // console.log(`insert (move-forward): [${i_start},${i}), [${j_start},${j}) => "${sequence.toString()}"`);
                edits.append(Edit.createPureInsertion(sequence));
                continue;
            }
            // If both OLD and NEW are blocks, that means both point to the others' future, so we have to pick which one
            // we're going to emit first, which will affect what things end up being equalities and what end up being delete/insert
            // pairs.  Whichever change leaps further into the future, we'll decide is the move.
            if (old_other !== undefined && new_other !== undefined) {
                if (new_other - j >= old_other - i) { // NEW is further away?  Then insert NEW; later we'll delete from OLD
                    while (i < NA_length && ((_e = NA[i].other_offset) !== null && _e !== void 0 ? _e : -1) > j) { // insert until no longer in the block
                        ++i;
                    }
                    const sequence = new_file.getSubsequence(i_start, i - i_start);
                    // console.log(`insert (move-backward): [${i_start},${i}), [${j_start},${j}) => "${sequence.toString()}"`);
                    edits.append(Edit.createPureInsertion(sequence));
                    continue;
                }
                else {
                    while (j < OA_length && ((_f = OA[j].other_offset) !== null && _f !== void 0 ? _f : -1) > i) { // delete until no longer in the block
                        ++j;
                    }
                    const sequence = old_file.getSubsequence(j_start, j - j_start);
                    // console.log(`delete (move-forward): [${i_start},${i}), [${j_start},${j}) => "${sequence.toString()}"`);
                    edits.append(Edit.createPureDeletion(sequence));
                    continue;
                }
            }
            // Gather from both sides until we have hit some sort of equality, or finished with that file.
            while (i < NA_length && (j == OA_length || NA[i].other_offset === undefined)) { // `j == OA_length` is for the "virtual line" at the end
                ++i;
            }
            while (j < OA_length && (i == NA_length || OA[j].other_offset === undefined)) { // `i == NA_length` is for the "virtual line" at the end
                ++j;
            }
            const prev_seq = old_file.getSubsequence(j_start, j - j_start);
            const next_seq = new_file.getSubsequence(i_start, i - i_start);
            // console.log(`modification: [${i_start},${i}), [${j_start},${j}) => "${prev_seq.toString()}" / "${next_seq.toString()}"`);
            edits.append(new Edit(prev_seq, next_seq));
        }
    }
}
exports.Engine = Engine;
// Subclass of difference engine that operates on strings
class StringEngine extends Engine {
    /**
     * Returns edits, with differences on a per-character basis.  This is most-detailed, but often not what a human might expect to see.
     */
    getEditsByCharacter(prev, next) {
        return this.getEdits(ArrayView.fromCharacters(prev), ArrayView.fromCharacters(next));
    }
    /**
     * Returns edits, first splitting the string into tokens, treating anything not matching a token as an individual character.
     */
    getEditsByToken(prev, next, re) {
        return this.getEdits(ArrayView.fromTokens(prev, re), ArrayView.fromTokens(next, re));
    }
    /**
     * Returns edits, using the line as the unit of comparison.
     */
    getEditsByLine(prev, next) {
        return this.getEdits(ArrayView.fromLines(prev), ArrayView.fromLines(next));
    }
    /**
     * Returns edits, assuming configuration that is better for prose.
     */
    getEditsByProse(prev, next) {
        return this.getEdits(ArrayView.fromPlainProse(prev), ArrayView.fromPlainProse(next));
    }
    /**
     * Converts an `EditScript<string>` that was generated by a difference engine into a list
     * of `insert` and `delete` instructions relative to the "previous" string used in the
     * original diff.
     *
     * @param rollingUpdates if true, indexes are listed as if the underlying string is being transformed as we go, otherwise they are relative to the original string
     */
    static getStringOffsets(script, rollingUpdates) {
        const result = [];
        let idx = 0;
        script.visitEditsForward(edit => {
            if (!edit.isEquality()) {
                if (!edit.prev.empty) {
                    result[result.length] = {
                        op: "delete",
                        idx: idx,
                        len: edit.prev.length,
                    };
                }
                if (!edit.next.empty) {
                    result[result.length] = {
                        op: "insert",
                        idx: idx,
                        txt: edit.next.getCopy().join(''),
                    };
                }
            }
            idx += rollingUpdates ? edit.next.length : edit.prev.length;
            return null; // don't change the script
        });
        return result;
    }
}
exports.StringEngine = StringEngine;
//# sourceMappingURL=index.js.map