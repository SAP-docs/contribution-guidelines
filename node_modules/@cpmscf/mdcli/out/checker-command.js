"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EXIT_CODE_BAD_CONFIG = void 0;
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const safe_1 = require("colors/safe");
const mdlib_1 = require("@cpmscf/mdlib");
const scanner_1 = require("./scanner");
const mdlib_2 = require("@cpmscf/mdlib");
const path_1 = require("path");
const { writeFile } = require("fs").promises;
const unified = require("unified");
const parse = require("remark-parse");
const stringify = require("remark-stringify");
const frontmatter = require("remark-frontmatter");
const EXIT_CODE_ERORRS = 2;
const EXIT_CODE_NO_FILES = 3;
const EXIT_CODE_BAD_MKDOCS_CONFIG = 4;
exports.EXIT_CODE_BAD_CONFIG = 5;
class RuleCommand extends command_1.Command {
    getChecks(_) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return () => Promise.resolve([]);
        });
    }
    getConfig(ctor = this.ctor) {
        const config = Object.assign(Object.assign({}, mdlib_1.loadConfig()), this.parse(ctor).flags);
        if (!config.path)
            this.error("Missing required flag: path. Provide configuration in a .cdcrc config file or use the --path argument.", { exit: exports.EXIT_CODE_BAD_CONFIG });
        return config;
    }
    run() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const conf = this.getConfig();
            const mdPattern = "**/*.{markdown,md}";
            const processor = unified()
                .use(parse)
                .use(stringify)
                .use(frontmatter, ["yaml", "toml"]);
            let mkdocsConfig = mdlib_1.MKDOCS_DEFAULTS;
            try {
                mkdocsConfig = yield this.getMkdocsConfig();
            }
            catch (error) {
                // Ignore - this is purely for TargetFinder variable support, which currently is tied to mkdocs.
                // Enforcing this would break other commands. Should be addressed once other frameworks are supported as well
            }
            const finder = new mdlib_2.TargetFinder(conf, mkdocsConfig);
            const rules = yield this.getRules(finder, processor);
            rules.forEach(r => processor.use(r));
            const scanner = new scanner_1.default(mdPattern, processor, {
                ignore: (conf.ignore || []).flatMap((p) => [p, path_1.join(conf.path, p, "**")]),
            }, conf);
            const files = [...yield scanner.start(),
                ...yield (yield this.getChecks(finder))()];
            if (files.length === 0) {
                this.error(`No files found in ${path_1.join(process.cwd(), mdPattern)}.`, {
                    exit: EXIT_CODE_NO_FILES,
                });
            }
            const messages = files.reduce((acc, x) => {
                acc.push(...x.messages);
                return acc;
            }, []);
            const issueCount = messages.length;
            const potentialFixCount = messages.reduce((c, d) => {
                return d.fix ? ++c : c;
            }, 0);
            let fixCount = 0;
            if (issueCount === 0) {
                this.log("No issues found");
                return;
            }
            for (const file of files) {
                const fileIssueCount = file.messages.length;
                if (fileIssueCount === 0)
                    continue;
                this.warn(`Found ${fileIssueCount}${fileIssueCount === 1 ? " issue" : " issues"} in ${file.path}:`);
                for (const issue of file.messages) {
                    const location = `${file.path}:${issue.location.start.line}:${issue.location.start.column}`;
                    const message = `${issue.message} (${issue.shortLink})`;
                    const fixInfo = this.getFixInfo(issue, Boolean(conf.color));
                    const logEntry = `${location} ${message}${fixInfo}`;
                    this.warn(`${logEntry}`);
                }
                if (file.messages.length > 0 && conf.fix) {
                    try {
                        // eslint-disable-next-line no-await-in-loop
                        yield writeFile(path_1.join(conf.path, file.path), mdlib_2.applyFixes(file));
                        fixCount += file.messages.reduce((c, d) => {
                            return d.fix ? ++c : c;
                        }, 0);
                    }
                    catch (error) {
                        console.error(error);
                    }
                }
            }
            let summary = `Found ${issueCount}${issueCount === 1 ? " issue" : " issues"}`;
            if (potentialFixCount) {
                if (conf.fix) {
                    summary += `, ${fixCount} out of which were automatically fixed.`;
                }
                else {
                    summary += `, ${potentialFixCount} out of which can potentially be resolved by adding the --fix option.`;
                }
            }
            this.warn(summary);
            if (!conf.fix || fixCount < issueCount) {
                this.exit(EXIT_CODE_ERORRS);
            }
        });
    }
    getFixInfo(issue, color) {
        if (!issue.fix)
            return "";
        let fixInfo;
        if (color) {
            fixInfo = `: ${issue.fix.diffs.map((part) => {
                // green for additions, red for deletions
                // grey for common parts
                const color = part.added ? safe_1.green :
                    part.removed ? safe_1.red : safe_1.gray;
                return color(part.value);
            }).join("")}`;
        }
        else {
            fixInfo = `\n\t\t'${issue.content}'\nshould be\t'${issue.fix.content}'`;
        }
        return fixInfo;
    }
    getMkdocsConfig() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const config = this.getConfig();
            try {
                return mdlib_1.loadMkdocsConfig(config);
            }
            catch (error) {
                this.error(error, {
                    exit: EXIT_CODE_BAD_MKDOCS_CONFIG,
                });
            }
        });
    }
}
exports.default = RuleCommand;
RuleCommand.flags = {
    help: command_1.flags.help({ char: "h" }),
    path: command_1.flags.string({ char: "p", description: "Path to check" }),
    fix: command_1.flags.boolean({ char: "f", description: "Automatically fix reported issues" }),
    config: command_1.flags.string({ char: "c", description: "Path to Mkdocs configuration file, relative to --path" }),
    color: command_1.flags.boolean({ char: "C", description: "Print colored diffs" }),
    ignore: command_1.flags.string({ char: "i", description: "Paths to ignore, relative to --path.", multiple: true }),
};
//# sourceMappingURL=checker-command.js.map